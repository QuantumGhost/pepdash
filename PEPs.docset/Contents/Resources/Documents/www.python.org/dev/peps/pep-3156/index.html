<!doctype html>
<!--[if lt IE 7]>   <html class="no-js ie6 lt-ie7 lt-ie8 lt-ie9">   <![endif]-->
<!--[if IE 7]>      <html class="no-js ie7 lt-ie8 lt-ie9">          <![endif]-->
<!--[if IE 8]>      <html class="no-js ie8 lt-ie9">                 <![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" lang="en" dir="ltr">  <!--<![endif]-->


<!-- Mirrored from www.python.org/dev/peps/pep-3156/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 03 Sep 2015 04:35:42 GMT -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <link rel="prefetch" href="../../../../ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js">

    <meta name="application-name" content="Python.org">
    <meta name="msapplication-tooltip" content="The official home of the Python Programming Language">
    <meta name="apple-mobile-web-app-title" content="Python.org">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="HandheldFriendly" content="True">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="cleartype" content="on">
    <meta http-equiv="imagetoolbar" content="false">

    <script src="../../../static/js/libs/modernizr.js"></script>

    <link href="../../../static/stylesheets/style.css" rel="stylesheet" type="text/css" title="default" />
    <link href="../../../static/stylesheets/mq.css" rel="stylesheet" type="text/css" media="not print, braille, embossed, speech, tty" />
    

    <!--[if (lte IE 8)&(!IEMobile)]>
    <link href="/static/stylesheets/no-mq.css" rel="stylesheet" type="text/css" media="screen" />
    
    
    <![endif]-->

    
    <link rel="icon" type="image/x-icon" href="https://www.python.org/static/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../static/apple-touch-icon-144x144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../static/apple-touch-icon-114x114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../static/apple-touch-icon-72x72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../../../static/apple-touch-icon-precomposed.png">
    <link rel="apple-touch-icon" href="../../../static/apple-touch-icon-precomposed.png">

    
    <meta name="msapplication-TileImage" content="/static/metro-icon-144x144-precomposed.png"><!-- white shape -->
    <meta name="msapplication-TileColor" content="#3673a5"><!-- python blue -->
    <meta name="msapplication-navbutton-color" content="#3673a5">

    <meta property="og:site_name" content="Python.org">
    <meta property="og:type" content="website">

    <title>PEP 3156 -- Asynchronous IO Support Rebooted: the &quot;asyncio&quot; Module | Python.org</title>
    <meta property="og:title" content="Welcome to Python.org">

    
    <meta name="description" content="The official home of the Python Programming Language">
    <meta name="og:description" content="The official home of the Python Programming Language">
    <meta name="keywords" content="Python programming language object oriented web free open source software license documentation download community">
    <meta property="og:tag" content="Python programming language object oriented web free open source software license documentation download community">
    <meta property="og:published_time" content="">
    <meta property="og:modified_time" content="">
    <meta property="og:author" content="">
    <meta property="og:section" content=""> 
    <meta property="og:url" content="">
    <meta property="og:image" content="">
    <meta property="og:video" content="">

    <link rel="author" href="https://www.python.org/static/humans.txt">

    

    
    <script type="application/ld+json">
     {
       "@context": "http://schema.org",
       "@type": "WebSite",
       "url": "https://www.python.org/",
       "potentialAction": {
         "@type": "SearchAction",
         "target": "https://www.python.org/search/?q={search_term_string}",
         "query-input": "required name=search_term_string"
       }
     }
    </script>

    
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-39055973-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
    
</head>

<body class="python pages pep-page">

    <div id="touchnav-wrapper">

        <div id="nojs" class="do-not-print">
            <p><strong>Notice:</strong> While Javascript is not essential for this website, your interaction with the content will be limited. Please turn Javascript on for the full experience. </p>
        </div>

        <!--[if lt IE 8]>
        <div id="oldie-warning" class="do-not-print">
            <p><strong>Notice:</strong> Your browser is <em>ancient</em> and <a href="http://www.ie6countdown.com/">Microsoft agrees</a>. <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience a better web.</p>
        </div>
        <![endif]-->

        <!-- Sister Site Links -->
        <div id="top" class="top-bar do-not-print">

            <nav class="meta-navigation container" role="navigation">

                
                <div class="skip-link screen-reader-text">
                    <a href="#content" title="Skip to content">Skip to content</a>
                </div>

                
                <a id="close-python-network" class="jump-link" href="#python-network" aria-hidden="true">
                    <span aria-hidden="true" class="icon-arrow-down"><span>&#9660;</span></span> Close
                </a>

                

<ul class="menu" role="tree">
    
    <li class="python-meta ">
        <a href="https://www.python.org/" title="The Python Programming Language" >Python</a>
    </li>
    
    <li class="psf-meta ">
        <a href="https://www.python.org/psf-landing/" title="The Python Software Foundation" >PSF</a>
    </li>
    
    <li class="docs-meta ">
        <a href="https://docs.python.org/" title="Python Documentation" >Docs</a>
    </li>
    
    <li class="pypi-meta ">
        <a href="https://pypi.python.org/" title="Python Package Index" >PyPI</a>
    </li>
    
    <li class="jobs-meta ">
        <a href="https://www.python.org/jobs/" title="Python Job Board" >Jobs</a>
    </li>
    
    <li class="shop-meta ">
        <a href="https://www.python.org/community/" title="Python Community" >Community</a>
    </li>
    
</ul>


                <a id="python-network" class="jump-link" href="#top" aria-hidden="true">
                    <span aria-hidden="true" class="icon-arrow-up"><span>&#9650;</span></span> The Python Network
                </a>

            </nav>

        </div>

        <!-- Header elements -->
        <header class="main-header" role="banner">
            <div class="container">

                <h1 class="site-headline">
                    <a href="https://www.python.org/"><img class="python-logo" src="../../../static/img/python-logo.png" alt="python&trade;"></a>
                </h1>

                <div class="options-bar do-not-print">

                    
                    <a id="site-map-link" class="jump-to-menu" href="#site-map"><span class="menu-icon">&equiv;</span> Menu</a><form class="search-the-site" action="https://www.python.org/search/" method="get">
                        <fieldset title="Search Python.org">

                            <span aria-hidden="true" class="icon-search"></span>

                            <label class="screen-reader-text" for="id-search-field">Search This Site</label>
                            <input id="id-search-field" name="q" type="search" role="textbox" class="search-field" placeholder="Search" value="" tabindex="1">

                            <button type="submit" name="submit" id="submit" class="search-button" title="Submit this Search" tabindex="3">
                                GO
                            </button>

                            
                            <!--[if IE]><input type="text" style="display: none;" disabled="disabled" size="1" tabindex="4"><![endif]-->

                        </fieldset>
                    </form><span class="breaker"></span><div class="adjust-font-size" aria-hidden="true">
                        <ul class="navigation menu" aria-label="Adjust Text Size on Page">
                            <li class="tier-1 last" aria-haspopup="true">
                                <a href="#" class="action-trigger"><strong><small>A</small> A</strong></a>
                                <ul class="subnav menu">
                                    <li class="tier-2 element-1" role="treeitem"><a class="text-shrink" title="Make Text Smaller" href="javascript:;">Smaller</a></li>
                                    <li class="tier-2 element-2" role="treeitem"><a class="text-grow" title="Make Text Larger" href="javascript:;">Larger</a></li>
                                    <li class="tier-2 element-3" role="treeitem"><a class="text-reset" title="Reset any font size changes I have made" href="javascript:;">Reset</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><div class="winkwink-nudgenudge">
                        <ul class="navigation menu" aria-label="Social Media Navigation">
                            <li class="tier-1 last" aria-haspopup="true">
                                <a href="#" class="action-trigger">Socialize</a>
                                <ul class="subnav menu">
                                    <li class="tier-2 element-1" role="treeitem"><a href="http://plus.google.com/+Python"><span aria-hidden="true" class="icon-google-plus"></span>Google+</a></li>
                                    <li class="tier-2 element-2" role="treeitem"><a href="http://www.facebook.com/pythonlang?fref=ts"><span aria-hidden="true" class="icon-facebook"></span>Facebook</a></li>
                                    <li class="tier-2 element-3" role="treeitem"><a href="http://twitter.com/ThePSF"><span aria-hidden="true" class="icon-twitter"></span>Twitter</a></li>
                                    <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/community/irc/"><span aria-hidden="true" class="icon-freenode"></span>Chat on IRC</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div><div class="account-signin">
                        <ul class="navigation menu" aria-label="Social Media Navigation">
                            <li class="tier-1 last" aria-haspopup="true">
                                
                                <a href="https://www.python.org/accounts/login/" title="Sign Up or Sign In to Python.org">Sign In</a>
                                <ul class="subnav menu">
                                    <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/accounts/signup/">Sign Up / Register</a></li>
                                    <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/accounts/login/">Sign In</a></li>
                                </ul>
                                
                            </li>
                        </ul>
                    </div>

                </div><!-- end options-bar -->

                <nav id="mainnav" class="python-navigation main-navigation do-not-print" role="navigation">
                    
                        
<ul class="navigation menu" role="menubar" aria-label="Main Navigation">
  
    
    
    <li id="about" class="tier-1 element-1  " aria-haspopup="true">
        <a href="https://www.python.org/about/" title="" class="">About</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/about/apps/" title="">Applications</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/about/quotes/" title="">Quotes</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/about/gettingstarted/" title="">Getting Started</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/about/help/" title="">Help</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="downloads" class="tier-1 element-2  " aria-haspopup="true">
        <a href="https://www.python.org/downloads/" title="" class="">Downloads</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/downloads/" title="">All releases</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/downloads/source/" title="">Source code</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/downloads/windows/" title="">Windows</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/downloads/mac-osx/" title="">Mac OS X</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/download/other/" title="">Other Platforms</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://docs.python.org/3/license.html" title="">License</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/download/alternatives" title="">Alternative Implementations</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="documentation" class="tier-1 element-3  " aria-haspopup="true">
        <a href="https://www.python.org/doc/" title="" class="">Documentation</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/doc/" title="">Docs</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/doc/av" title="">Audio/Visual Talks</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://wiki.python.org/moin/BeginnersGuide" title="">Beginner&#39;s Guide</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://docs.python.org/devguide/" title="">Developer&#39;s Guide</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://docs.python.org/faq/" title="">FAQ</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="http://wiki.python.org/moin/Languages" title="">Non-English Docs</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="../index.html" title="">PEP Index</a></li>
    
        <li class="tier-2 element-8" role="treeitem"><a href="https://wiki.python.org/moin/PythonBooks" title="">Python Books</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="community" class="tier-1 element-4  " aria-haspopup="true">
        <a href="https://www.python.org/community/" title="" class="">Community</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/community/diversity/" title="">Diversity</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/community/irc/" title="">IRC</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/community/lists/" title="">Mailing Lists</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/community/workshops/" title="">Python Conferences</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/community/sigs/" title="">Special Interest Groups</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://wiki.python.org/moin/" title="">Python Wiki</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/community/logos/" title="">Python Logo</a></li>
    
        <li class="tier-2 element-8" role="treeitem"><a href="https://www.python.org/community/merchandise/" title="">Merchandise</a></li>
    
        <li class="tier-2 element-9" role="treeitem"><a href="https://www.python.org/community/awards" title="">Community Awards</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="success-stories" class="tier-1 element-5  " aria-haspopup="true">
        <a href="https://www.python.org/about/success/" title="success-stories" class="">Success Stories</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/about/success/#arts" title="">Arts</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/about/success/#business" title="">Business</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/about/success/#education" title="">Education</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/about/success/#engineering" title="">Engineering</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/about/success/#government" title="">Government</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://www.python.org/about/success/#scientific" title="">Scientific</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/about/success/#software-development" title="">Software Development</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="news" class="tier-1 element-6  " aria-haspopup="true">
        <a href="https://www.python.org/blogs/" title="News from around the Python world" class="">News</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/blogs/" title="Python Insider Blog Posts">Python News</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="http://planetpython.org/" title="Planet Python">Community News</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="http://pyfound.blogspot.com/" title="PSF Blog">PSF News</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="http://pycon.blogspot.com/" title="PyCon Blog">PyCon News</a></li>
    
</ul>

        
    </li>
    
    
    
    <li id="events" class="tier-1 element-7  " aria-haspopup="true">
        <a href="https://www.python.org/events/" title="" class="">Events</a>
        
            

<ul class="subnav menu" role="menu" aria-hidden="true">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/events/python-events/" title="">Python Events</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/events/python-user-group/" title="">User Group Events</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/events/python-events/past/" title="">Python Events Archive</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/events/python-user-group/past/" title="">User Group Events Archive</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://wiki.python.org/moin/PythonEventsCalendar#Submitting_an_Event" title="">Submit an Event</a></li>
    
</ul>

        
    </li>
    
    
    
    
  
</ul>

                    
                </nav>

                <div class="header-banner "> <!-- for optional "do-not-print" class -->
                    
                    
                </div>

                
                

             </div><!-- end .container -->
        </header>

        <div id="content" class="content-wrapper">
            <!-- Main Content Column -->
            <div class="container">

                <section class="main-content with-left-sidebar" role="main">

                    
<ul class="breadcrumbs menu">
    <li>
        <a href="https://www.python.org/" title="The Python Programming Language">Python</a><span class="prompt">&gt;&gt;&gt;</span>
    </li>
    <li>
        <a href="https://www.python.org/dev/">Python Developer's Guide</a><span class="prompt">&gt;&gt;&gt;</span>
    </li>
    <li>
        <a href="../index.html">PEP Index</a><span class="prompt">&gt;&gt;&gt;</span>
    </li>
    <li>PEP 3156 -- Asynchronous IO Support Rebooted: the &quot;asyncio&quot; Module</li>
</ul>


                    
<style>
   .pep-page pre {
        padding: .5em;
        background: inherit;
        border-left: 0px;
        -webkit-box-shadow: 0 0 0 0;
        -moz-box-shadow: 0 0 0 0;
        box-shadow: 0 0 0 0;
   }
</style>

    
    <article class="text">
        

        <header class="article-header">
            <h1 class="page-title">PEP 3156 -- Asynchronous IO Support Rebooted: the &quot;asyncio&quot; Module</h1>
        </header>

        <!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<html>
 <body>
  <table class="rfc2822 docutils field-list" frame="void" rules="none">
   <col class="field-name">
   </col>
   <col class="field-body">
   </col>
   <tbody valign="top">
    <tr class="field">
     <th class="field-name">
      PEP:
     </th>
     <td class="field-body">
      3156
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Title:
     </th>
     <td class="field-body">
      Asynchronous IO Support Rebooted: the "asyncio" Module
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Author:
     </th>
     <td class="field-body">
      Guido van Rossum &lt;guido at python.org&gt;
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      BDFL-Delegate:
     </th>
     <td class="field-body">
      Antoine Pitrou &lt;
      <a class="reference external" href="mailto:antoine@python.org">
       antoine@python.org
      </a>
      &gt;
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Discussions-To:
     </th>
     <td class="field-body">
      &lt;
      <a class="reference external" href="mailto:python-tulip@googlegroups.com?subject=PEP%203156">
       python-tulip at googlegroups.com
      </a>
      &gt;
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Status:
     </th>
     <td class="field-body">
      Final
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Type:
     </th>
     <td class="field-body">
      Standards Track
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Created:
     </th>
     <td class="field-body">
      12-Dec-2012
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Post-History:
     </th>
     <td class="field-body">
      21-Dec-2012
     </td>
    </tr>
    <tr class="field">
     <th class="field-name">
      Resolution:
     </th>
     <td class="field-body">
      <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130419.html">
       https://mail.python.org/pipermail/python-dev/2013-November/130419.html
      </a>
     </td>
    </tr>
   </tbody>
  </table>
  <hr/>
  <div class="contents topic" id="contents">
   <p class="topic-title first">
    Contents
   </p>
   <ul class="simple">
    <li>
     <a class="reference internal" href="#abstract" id="id1">
      Abstract
     </a>
    </li>
    <li>
     <a class="reference internal" href="#introduction" id="id2">
      Introduction
     </a>
     <ul>
      <li>
       <a class="reference internal" href="#status" id="id3">
        Status
       </a>
      </li>
      <li>
       <a class="reference internal" href="#dependencies" id="id4">
        Dependencies
       </a>
      </li>
      <li>
       <a class="reference internal" href="#module-namespace" id="id5">
        Module Namespace
       </a>
      </li>
      <li>
       <a class="reference internal" href="#interoperability" id="id6">
        Interoperability
       </a>
      </li>
      <li>
       <a class="reference internal" href="#transports-and-protocols" id="id7">
        Transports and Protocols
       </a>
      </li>
     </ul>
    </li>
    <li>
     <a class="reference internal" href="#event-loop-interface-specification" id="id8">
      Event Loop Interface Specification
     </a>
     <ul>
      <li>
       <a class="reference internal" href="#event-loop-policy-getting-and-setting-the-current-event-loop" id="id9">
        Event Loop Policy: Getting and Setting the Current Event Loop
       </a>
       <ul>
        <li>
         <a class="reference internal" href="#passing-an-event-loop-around-explicitly" id="id10">
          Passing an Event Loop Around Explicitly
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a class="reference internal" href="#specifying-times" id="id11">
        Specifying Times
       </a>
      </li>
      <li>
       <a class="reference internal" href="#embedded-event-loops" id="id12">
        Embedded Event Loops
       </a>
      </li>
      <li>
       <a class="reference internal" href="#event-loop-classes" id="id13">
        Event Loop Classes
       </a>
      </li>
      <li>
       <a class="reference internal" href="#event-loop-methods-overview" id="id14">
        Event Loop Methods Overview
       </a>
      </li>
      <li>
       <a class="reference internal" href="#event-loop-methods" id="id15">
        Event Loop Methods
       </a>
       <ul>
        <li>
         <a class="reference internal" href="#starting-stopping-and-closing" id="id16">
          Starting, Stopping and Closing
         </a>
        </li>
        <li>
         <a class="reference internal" href="#basic-callbacks" id="id17">
          Basic Callbacks
         </a>
        </li>
        <li>
         <a class="reference internal" href="#thread-interaction" id="id18">
          Thread interaction
         </a>
        </li>
        <li>
         <a class="reference internal" href="#internet-name-lookups" id="id19">
          Internet name lookups
         </a>
        </li>
        <li>
         <a class="reference internal" href="#internet-connections" id="id20">
          Internet connections
         </a>
        </li>
        <li>
         <a class="reference internal" href="#wrapped-socket-methods" id="id21">
          Wrapped Socket Methods
         </a>
        </li>
        <li>
         <a class="reference internal" href="#i-o-callbacks" id="id22">
          I/O Callbacks
         </a>
        </li>
        <li>
         <a class="reference internal" href="#pipes-and-subprocesses" id="id23">
          Pipes and Subprocesses
         </a>
        </li>
        <li>
         <a class="reference internal" href="#signal-callbacks" id="id24">
          Signal callbacks
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a class="reference internal" href="#mutual-exclusion-of-callbacks" id="id25">
        Mutual Exclusion of Callbacks
       </a>
      </li>
      <li>
       <a class="reference internal" href="#exceptions" id="id26">
        Exceptions
       </a>
      </li>
      <li>
       <a class="reference internal" href="#handles" id="id27">
        Handles
       </a>
      </li>
      <li>
       <a class="reference internal" href="#servers" id="id28">
        Servers
       </a>
      </li>
      <li>
       <a class="reference internal" href="#futures" id="id29">
        Futures
       </a>
      </li>
      <li>
       <a class="reference internal" href="#transports" id="id30">
        Transports
       </a>
       <ul>
        <li>
         <a class="reference internal" href="#methods-for-all-transports" id="id31">
          Methods For All Transports
         </a>
        </li>
        <li>
         <a class="reference internal" href="#bidirectional-stream-transports" id="id32">
          Bidirectional Stream Transports
         </a>
        </li>
        <li>
         <a class="reference internal" href="#unidirectional-stream-transports" id="id33">
          Unidirectional Stream Transports
         </a>
        </li>
        <li>
         <a class="reference internal" href="#datagram-transports" id="id34">
          Datagram Transports
         </a>
        </li>
        <li>
         <a class="reference internal" href="#subprocess-transports" id="id35">
          Subprocess Transports
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a class="reference internal" href="#protocols" id="id36">
        Protocols
       </a>
       <ul>
        <li>
         <a class="reference internal" href="#stream-protocols" id="id37">
          Stream Protocols
         </a>
        </li>
        <li>
         <a class="reference internal" href="#datagram-protocols" id="id38">
          Datagram Protocols
         </a>
        </li>
        <li>
         <a class="reference internal" href="#subprocess-protocol" id="id39">
          Subprocess Protocol
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a class="reference internal" href="#callback-style" id="id40">
        Callback Style
       </a>
      </li>
     </ul>
    </li>
    <li>
     <a class="reference internal" href="#coroutines-and-the-scheduler" id="id41">
      Coroutines and the Scheduler
     </a>
     <ul>
      <li>
       <a class="reference internal" href="#coroutines" id="id42">
        Coroutines
       </a>
      </li>
      <li>
       <a class="reference internal" href="#waiting-for-multiple-coroutines" id="id43">
        Waiting for Multiple Coroutines
       </a>
      </li>
      <li>
       <a class="reference internal" href="#sleeping" id="id44">
        Sleeping
       </a>
      </li>
      <li>
       <a class="reference internal" href="#tasks" id="id45">
        Tasks
       </a>
      </li>
      <li>
       <a class="reference internal" href="#the-scheduler" id="id46">
        The Scheduler
       </a>
      </li>
      <li>
       <a class="reference internal" href="#convenience-utilities" id="id47">
        Convenience Utilities
       </a>
      </li>
     </ul>
    </li>
    <li>
     <a class="reference internal" href="#synchronization" id="id48">
      Synchronization
     </a>
     <ul>
      <li>
       <a class="reference internal" href="#locks" id="id49">
        Locks
       </a>
      </li>
      <li>
       <a class="reference internal" href="#queues" id="id50">
        Queues
       </a>
      </li>
     </ul>
    </li>
    <li>
     <a class="reference internal" href="#miscellaneous" id="id51">
      Miscellaneous
     </a>
     <ul>
      <li>
       <a class="reference internal" href="#logging" id="id52">
        Logging
       </a>
      </li>
      <li>
       <a class="reference internal" href="#sigchld-handling-on-unix" id="id53">
        <tt class="docutils literal">
         SIGCHLD
        </tt>
        handling on UNIX
       </a>
      </li>
     </ul>
    </li>
    <li>
     <a class="reference internal" href="#wish-list" id="id54">
      Wish List
     </a>
    </li>
    <li>
     <a class="reference internal" href="#open-issues" id="id55">
      Open Issues
     </a>
    </li>
    <li>
     <a class="reference internal" href="#references" id="id56">
      References
     </a>
    </li>
    <li>
     <a class="reference internal" href="#acknowledgments" id="id57">
      Acknowledgments
     </a>
    </li>
    <li>
     <a class="reference internal" href="#copyright" id="id58">
      Copyright
     </a>
    </li>
   </ul>
  </div>
  <div class="section" id="abstract">
   <h1>
    <a class="toc-backref" href="#id1">
     Abstract
    </a>
   </h1>
   <p>
    This is a proposal for asynchronous I/O in Python 3, starting at
Python 3.3.  Consider this the concrete proposal that is missing from
    <a class="reference external" href="../pep-3153/index.html">
     PEP 3153
    </a>
    .  The proposal includes a pluggable event loop, transport and
protocol abstractions similar to those in Twisted, and a higher-level
scheduler based on
    <tt class="docutils literal">
     yield from
    </tt>
    (
    <a class="reference external" href="../pep-0380/index.html">
     PEP 380
    </a>
    ).  The proposed package
name is
    <tt class="docutils literal">
     asyncio
    </tt>
    .
   </p>
  </div>
  <div class="section" id="introduction">
   <h1>
    <a class="toc-backref" href="#id2">
     Introduction
    </a>
   </h1>
   <div class="section" id="status">
    <h2>
     <a class="toc-backref" href="#id3">
      Status
     </a>
    </h2>
    <p>
     A reference implementation exists under the code name Tulip.  The
Tulip repo is linked from the References section at the end.  Packages
based on this repo will be provided on PyPI (see References) to enable
using the
     <tt class="docutils literal">
      asyncio
     </tt>
     package with Python 3.3 installations.
    </p>
    <p>
     As of October 20th 2013, the
     <tt class="docutils literal">
      asyncio
     </tt>
     package has been checked into
the Python 3.4 repository and released with Python 3.4-alpha-4, with
"provisional" API status.  This is an expression of confidence and
intended to increase early feedback on the API, and not intended to
force acceptance of the PEP.  The expectation is that the package will
keep provisional status in Python 3.4 and progress to final status in
Python 3.5.  Development continues to occur primarily in the Tulip
repo, with changes occasionally merged into the CPython repo.
    </p>
   </div>
   <div class="section" id="dependencies">
    <h2>
     <a class="toc-backref" href="#id4">
      Dependencies
     </a>
    </h2>
    <p>
     Python 3.3 is required for many of the proposed features.  The
reference implementation (Tulip) requires no new language or standard
library features beyond Python 3.3, no third-party modules or
packages, and no C code, except for the (optional) IOCP support on
Windows.
    </p>
   </div>
   <div class="section" id="module-namespace">
    <h2>
     <a class="toc-backref" href="#id5">
      Module Namespace
     </a>
    </h2>
    <p>
     The specification here lives in a new top-level package,
     <tt class="docutils literal">
      asyncio
     </tt>
     .
Different components live in separate submodules of the package.  The
package will import common APIs from their respective submodules and
make them available as package attributes (similar to the way the
email package works).  For such common APIs, the name of the submodule
that actually defines them is not part of the specification.  Less
common APIs may have to explicitly be imported from their respective
submodule, and in this case the submodule name is part of the
specification.
    </p>
    <p>
     Classes and functions defined without a submodule name are assumed to
live in the namespace of the top-level package.  (But do not confuse
these with methods of various classes, which for brevity are also used
without a namespace prefix in certain contexts.)
    </p>
   </div>
   <div class="section" id="interoperability">
    <h2>
     <a class="toc-backref" href="#id6">
      Interoperability
     </a>
    </h2>
    <p>
     The event loop is the place where most interoperability occurs.  It
should be easy for (Python 3.3 ports of) frameworks like Twisted,
Tornado, or even gevents to either adapt the default event loop
implementation to their needs using a lightweight adapter or proxy, or
to replace the default event loop implementation with an adaptation of
their own event loop implementation.  (Some frameworks, like Twisted,
have multiple event loop implementations.  This should not be a
problem since these all have the same interface.)
    </p>
    <p>
     In most cases it should be possible for two different third-party
frameworks to interoperate, either by sharing the default event loop
implementation (each using its own adapter), or by sharing the event
loop implementation of either framework.  In the latter case two
levels of adaptation would occur (from framework A's event loop to the
standard event loop interface, and from there to framework B's event
loop).  Which event loop implementation is used should be under
control of the main program (though a default policy for event loop
selection is provided).
    </p>
    <p>
     For this interoperability to be effective, the preferred direction of
adaptation in third party frameworks is to keep the default event loop
and adapt it to the framework's API.  Ideally all third party
frameworks would give up their own event loop implementation in favor
of the standard implementation.  But not all frameworks may be
satisfied with the functionality provided by the standard
implementation.
    </p>
    <p>
     In order to support both directions of adaptation, two separate APIs
are specified:
    </p>
    <ul class="simple">
     <li>
      An interface for managing the current event loop
     </li>
     <li>
      The interface of a conforming event loop
     </li>
    </ul>
    <p>
     An event loop implementation may provide additional methods and
guarantees, as long as these are called out in the documentation as
non-standard.  An event loop implementation may also leave certain
methods unimplemented if they cannot be implemented in the given
environment; however, such deviations from the standard API should be
considered only as a last resort, and only if the platform or
environment forces the issue.  (An example would be a platform where
there is a system event loop that cannot be started or stopped; see
"Embedded Event Loops" below.)
    </p>
    <p>
     The event loop API does not depend on
     <tt class="docutils literal">
      yield from
     </tt>
     .  Rather, it uses
a combination of callbacks, additional interfaces (transports and
protocols), and Futures.  The latter are similar to those defined in
     <a class="reference external" href="../pep-3148/index.html">
      PEP 3148
     </a>
     , but have a different implementation and are not tied to
threads.  In particular, the
     <tt class="docutils literal">
      result()
     </tt>
     method raises an exception
instead of blocking when a result is not yet ready; the user is
expected to use callbacks (or
     <tt class="docutils literal">
      yield from
     </tt>
     ) to wait for the result.
    </p>
    <p>
     All event loop methods specified as returning a coroutine are allowed
to return either a Future or a coroutine, at the implementation's
choice (the standard implementation always returns coroutines).  All
event loop methods documented as accepting coroutine arguments
     <em>
      must
     </em>
     accept both Futures and coroutines for such arguments.  (A convenience
function,
     <tt class="docutils literal">
      async()
     </tt>
     , exists to convert an argument that is either a
coroutine or a Future into a Future.)
    </p>
    <p>
     For users (like myself) who don't like using callbacks, a scheduler is
provided for writing asynchronous I/O code as coroutines using the
     <a class="reference external" href="../pep-0380/index.html">
      PEP
380
     </a>
     <tt class="docutils literal">
      yield from
     </tt>
     expressions.  The scheduler is not pluggable;
pluggability occurs at the event loop level, and the standard
scheduler implementation should work with any conforming event loop
implementation.  (In fact this is an important litmus test for
conforming implementations.)
    </p>
    <p>
     For interoperability between code written using coroutines and other
async frameworks, the scheduler defines a Task class that behaves like a
Future.  A framework that interoperates at the event loop level can
wait for a Future to complete by adding a callback to the Future.
Likewise, the scheduler offers an operation to suspend a coroutine
until a callback is called.
    </p>
    <p>
     The event loop API provides limited interoperability with threads:
there is an API to submit a function to an executor (see
     <a class="reference external" href="../pep-3148/index.html">
      PEP 3148
     </a>
     )
which returns a Future that is compatible with the event loop, and
there is a method to schedule a callback with an event loop from
another thread in a thread-safe manner.
    </p>
   </div>
   <div class="section" id="transports-and-protocols">
    <h2>
     <a class="toc-backref" href="#id7">
      Transports and Protocols
     </a>
    </h2>
    <p>
     For those not familiar with Twisted, a quick explanation of the
relationship between transports and protocols is in order.  At the
highest level, the transport is concerned with
     <em>
      how
     </em>
     bytes are
transmitted, while the protocol determines
     <em>
      which
     </em>
     bytes to transmit
(and to some extent when).
    </p>
    <p>
     A different way of saying the same thing: a transport is an
abstraction for a socket (or similar I/O endpoint) while a protocol is
an abstraction for an application, from the transport's point of view.
    </p>
    <p>
     Yet another view is simply that the transport and protocol interfaces
     <em>
      together
     </em>
     define an abstract interface for using network I/O and
interprocess I/O.
    </p>
    <p>
     There is almost always a 1:1 relationship between transport and
protocol objects: the protocol calls transport methods to send data,
while the transport calls protocol methods to pass it data that has
been received.  Neither transport not protocol methods "block" -- they
set events into motion and then return.
    </p>
    <p>
     The most common type of transport is a bidirectional stream transport.
It represents a pair of buffered streams (one in each direction) that
each transmit a sequence of bytes.  The most common example of a
bidirectional stream transport is probably a TCP connection.  Another
common example is an SSL/TLS connection.  But there are some other things
that can be viewed this way, for example an SSH session or a pair of
UNIX pipes.  Typically there aren't many different transport
implementations, and most of them come with the event loop
implementation.  However, there is no requirement that all transports
must be created by calling an event loop method: a third party module
may well implement a new transport and provide a constructor or
factory function for it that simply takes an event loop as an argument
or calls
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     .
    </p>
    <p>
     Note that transports don't need to use sockets, not even if they use
TCP -- sockets are a platform-specific implementation detail.
    </p>
    <p>
     A bidirectional stream transport has two "ends": one end talks to
the network (or another process, or whatever low-level interface it
wraps), and the other end talks to the protocol.  The former uses
whatever API is necessary to implement the transport; but the
interface between transport and protocol is standardized by this PEP.
    </p>
    <p>
     A protocol can represent some kind of "application-level" protocol
such as HTTP or SMTP; it can also implement an abstraction shared by
multiple protocols, or a whole application.  A protocol's primary
interface is with the transport.  While some popular protocols (and
other abstractions) may have standard implementations, often
applications implement custom protocols.  It also makes sense to have
libraries of useful third party protocol implementations that can be
downloaded and installed from PyPI.
    </p>
    <p>
     There general notion of transport and protocol includes other
interfaces, where the transport wraps some other communication
abstraction.  Examples include interfaces for sending and receiving
datagrams (e.g. UDP), or a subprocess manager.  The separation of
concerns is the same as for bidirectional stream transports and
protocols, but the specific interface between transport and protocol
is different in each case.
    </p>
    <p>
     Details of the interfaces defined by the various standard types of
transports and protocols are given later.
    </p>
   </div>
  </div>
  <div class="section" id="event-loop-interface-specification">
   <h1>
    <a class="toc-backref" href="#id8">
     Event Loop Interface Specification
    </a>
   </h1>
   <div class="section" id="event-loop-policy-getting-and-setting-the-current-event-loop">
    <h2>
     <a class="toc-backref" href="#id9">
      Event Loop Policy: Getting and Setting the Current Event Loop
     </a>
    </h2>
    <p>
     Event loop management is controlled by an event loop policy, which is
a global (per-process) object.  There is a default policy, and an API
to change the policy.  A policy defines the notion of context; a
policy manages a separate event loop per context.  The default
policy's notion of context is defined as the current thread.
    </p>
    <p>
     Certain platforms or programming frameworks may change the default
policy to something more suitable to the expectations of the users of
that platform or framework.  Such platforms or frameworks must
document their policy and at what point during their initialization
sequence the policy is set, in order to avoid undefined behavior when
multiple active frameworks want to override the default policy.
(See also "Embedded Event Loops" below.)
    </p>
    <p>
     To get the event loop for current context, use
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     .
This returns an event loop object implementing the interface specified
below, or raises an exception in case no event loop has been set for
the current context and the current policy does not specify to create
one.  It should never return
     <tt class="docutils literal">
      None
     </tt>
     .
    </p>
    <p>
     To set the event loop for the current context, use
     <tt class="docutils literal">
      set_event_loop(event_loop)
     </tt>
     , where
     <tt class="docutils literal">
      event_loop
     </tt>
     is an event loop
object, i.e. an instance of
     <tt class="docutils literal">
      AbstractEventLoop
     </tt>
     , or
     <tt class="docutils literal">
      None
     </tt>
     .
It is okay to set the current event loop to
     <tt class="docutils literal">
      None
     </tt>
     , in
which case subsequent calls to
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     will raise an
exception.  This is useful for testing code that should not depend on
the existence of a default event loop.
    </p>
    <p>
     It is expected that
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     returns a different event
loop object depending on the context (in fact, this is the definition
of context).  It may create a new event loop object if none is set and
creation is allowed by the policy.  The default policy will create a
new event loop only in the main thread (as defined by threading.py,
which uses a special subclass for the main thread), and only if
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     is called before
     <tt class="docutils literal">
      set_event_loop()
     </tt>
     is ever
called.  (To reset this state, reset the policy.)  In other threads an
event loop must be explicitly set.  Other policies may behave
differently.  Event loop by the default policy creation is lazy;
i.e. the first call to
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     creates an event loop
instance if necessary and specified by the current policy.
    </p>
    <p>
     For the benefit of unit tests and other special cases there's a third
policy function:
     <tt class="docutils literal">
      new_event_loop()
     </tt>
     , which creates and returns a new
event loop object according to the policy's default rules.  To make
this the current event loop, you must call
     <tt class="docutils literal">
      set_event_loop()
     </tt>
     with
it.
    </p>
    <p>
     To change the event loop policy, call
     <tt class="docutils literal">
      set_event_loop_policy(policy)
     </tt>
     , where
     <tt class="docutils literal">
      policy
     </tt>
     is an event loop
policy object or
     <tt class="docutils literal">
      None
     </tt>
     .  If not
     <tt class="docutils literal">
      None
     </tt>
     , the policy object must be
an instance of
     <tt class="docutils literal">
      AbstractEventLoopPolicy
     </tt>
     that defines methods
     <tt class="docutils literal">
      get_event_loop()
     </tt>
     ,
     <tt class="docutils literal">
      set_event_loop(loop)
     </tt>
     and
     <tt class="docutils literal">
      new_event_loop()
     </tt>
     , all behaving like the functions described above.
    </p>
    <p>
     Passing a policy value of
     <tt class="docutils literal">
      None
     </tt>
     restores the default event loop
policy (overriding the alternate default set by the platform or
framework).  The default event loop policy is an instance of the class
     <tt class="docutils literal">
      DefaultEventLoopPolicy
     </tt>
     .  The current event loop policy object can
be retrieved by calling
     <tt class="docutils literal">
      get_event_loop_policy()
     </tt>
     .
    </p>
    <div class="section" id="passing-an-event-loop-around-explicitly">
     <h3>
      <a class="toc-backref" href="#id10">
       Passing an Event Loop Around Explicitly
      </a>
     </h3>
     <p>
      It is possible to write code that uses an event loop without relying
on a global or per-thread default event loop.  For this purpose, all
APIs that need access to the current event loop (and aren't methods on
an event class) take an optional keyword argument named
      <tt class="docutils literal">
       loop
      </tt>
      .  If
this argument is
      <tt class="docutils literal">
       None
      </tt>
      or unspecified, such APIs will call
      <tt class="docutils literal">
       get_event_loop()
      </tt>
      to get the default event loop, but if the
      <tt class="docutils literal">
       loop
      </tt>
      keyword argument is set to an event loop object, they will
use that event loop, and pass it along to any other such APIs they
call.  For example,
      <tt class="docutils literal">
       Future(loop=my_loop)
      </tt>
      will create a Future tied
to the event loop
      <tt class="docutils literal">
       my_loop
      </tt>
      .  When the default current event is
      <tt class="docutils literal">
       None
      </tt>
      , the
      <tt class="docutils literal">
       loop
      </tt>
      keyword argument is effectively mandatory.
     </p>
     <p>
      Note that an explicitly passed event loop must still belong to the
current thread; the
      <tt class="docutils literal">
       loop
      </tt>
      keyword argument does not magically
change the constraints on how an event loop can be used.
     </p>
    </div>
   </div>
   <div class="section" id="specifying-times">
    <h2>
     <a class="toc-backref" href="#id11">
      Specifying Times
     </a>
    </h2>
    <p>
     As usual in Python, all timeouts, intervals and delays are measured in
seconds, and may be ints or floats.  However, absolute times are not
specified as POSIX timestamps.  The accuracy, precision and epoch of
the clock are up to the implementation.
    </p>
    <p>
     The default implementation uses
     <tt class="docutils literal">
      time.monotonic()
     </tt>
     .  Books could be
written about the implications of this choice.  Better read the docs
for the standard library
     <tt class="docutils literal">
      time
     </tt>
     module.
    </p>
   </div>
   <div class="section" id="embedded-event-loops">
    <h2>
     <a class="toc-backref" href="#id12">
      Embedded Event Loops
     </a>
    </h2>
    <p>
     On some platforms an event loop is provided by the system.  Such a
loop may already be running when the user code starts, and there may
be no way to stop or close it without exiting from the program.  In
this case, the methods for starting, stopping and closing the event
loop may not be implementable, and
     <tt class="docutils literal">
      is_running()
     </tt>
     may always return
     <tt class="docutils literal">
      True
     </tt>
     .
    </p>
   </div>
   <div class="section" id="event-loop-classes">
    <h2>
     <a class="toc-backref" href="#id13">
      Event Loop Classes
     </a>
    </h2>
    <p>
     There is no actual class named
     <tt class="docutils literal">
      EventLoop
     </tt>
     .  There is an
     <tt class="docutils literal">
      AbstractEventLoop
     </tt>
     class which defines all the methods without
implementations, and serves primarily as documentation.  The following
concrete classes are defined:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       SelectorEventLoop
      </tt>
      is a concrete implementation of the full API
based on the
      <tt class="docutils literal">
       selectors
      </tt>
      module (new in Python 3.4).  The
constructor takes one optional argument, a
      <tt class="docutils literal">
       selectors.Selector
      </tt>
      object.  By default an instance of
      <tt class="docutils literal">
       selectors.DefaultSelector
      </tt>
      is
created and used.
     </li>
     <li>
      <tt class="docutils literal">
       ProactorEventLoop
      </tt>
      is a concrete implementation of the API except
for the I/O event handling and signal handling methods.  It is only
defined on Windows (or on other platforms which support a similar
API for "overlapped I/O").  The constructor takes one optional
argument, a
      <tt class="docutils literal">
       Proactor
      </tt>
      object.  By default an instance of
      <tt class="docutils literal">
       IocpProactor
      </tt>
      is created and used.  (The
      <tt class="docutils literal">
       IocpProactor
      </tt>
      class
is not specified by this PEP; it is just an implementation
detail of the
      <tt class="docutils literal">
       ProactorEventLoop
      </tt>
      class.)
     </li>
    </ul>
   </div>
   <div class="section" id="event-loop-methods-overview">
    <h2>
     <a class="toc-backref" href="#id14">
      Event Loop Methods Overview
     </a>
    </h2>
    <p>
     The methods of a conforming event loop are grouped into several
categories.  The first set of categories must be supported by all
conforming event loop implementations, with the exception that
embedded event loops may not implement the methods for starting,
stopping and closing.  (However, a partially-conforming event loop is
still better than nothing. :-)
    </p>
    <ul class="simple">
     <li>
      Starting, stopping and closing:
      <tt class="docutils literal">
       run_forever()
      </tt>
      ,
      <tt class="docutils literal">
       run_until_complete()
      </tt>
      ,
      <tt class="docutils literal">
       stop()
      </tt>
      ,
      <tt class="docutils literal">
       is_running()
      </tt>
      ,
      <tt class="docutils literal">
       close()
      </tt>
      .
     </li>
     <li>
      Basic and timed callbacks:
      <tt class="docutils literal">
       call_soon()
      </tt>
      ,
      <tt class="docutils literal">
       call_later()
      </tt>
      ,
      <tt class="docutils literal">
       call_at()
      </tt>
      ,
      <tt class="docutils literal">
       time()
      </tt>
      .
     </li>
     <li>
      Thread interaction:
      <tt class="docutils literal">
       call_soon_threadsafe()
      </tt>
      ,
      <tt class="docutils literal">
       run_in_executor()
      </tt>
      ,
      <tt class="docutils literal">
       set_default_executor()
      </tt>
      .
     </li>
     <li>
      Internet name lookups:
      <tt class="docutils literal">
       getaddrinfo()
      </tt>
      ,
      <tt class="docutils literal">
       getnameinfo()
      </tt>
      .
     </li>
     <li>
      Internet connections:
      <tt class="docutils literal">
       create_connection()
      </tt>
      ,
      <tt class="docutils literal">
       create_server()
      </tt>
      ,
      <tt class="docutils literal">
       create_datagram_endpoint()
      </tt>
      .
     </li>
     <li>
      Wrapped socket methods:
      <tt class="docutils literal">
       sock_recv()
      </tt>
      ,
      <tt class="docutils literal">
       sock_sendall()
      </tt>
      ,
      <tt class="docutils literal">
       sock_connect()
      </tt>
      ,
      <tt class="docutils literal">
       sock_accept()
      </tt>
      .
     </li>
    </ul>
    <p>
     The second set of categories
     <em>
      may
     </em>
     be supported by conforming event
loop implementations.  If not supported, they will raise
     <tt class="docutils literal">
      NotImplementedError
     </tt>
     .  (In the default implementation,
     <tt class="docutils literal">
      SelectorEventLoop
     </tt>
     on UNIX systems supports all of these;
     <tt class="docutils literal">
      SelectorEventLoop
     </tt>
     on Windows supports the I/O event handling
category;
     <tt class="docutils literal">
      ProactorEventLoop
     </tt>
     on Windows supports the pipes and
subprocess category.)
    </p>
    <ul class="simple">
     <li>
      I/O callbacks:
      <tt class="docutils literal">
       add_reader()
      </tt>
      ,
      <tt class="docutils literal">
       remove_reader()
      </tt>
      ,
      <tt class="docutils literal">
       add_writer()
      </tt>
      ,
      <tt class="docutils literal">
       remove_writer()
      </tt>
      .
     </li>
     <li>
      Pipes and subprocesses:
      <tt class="docutils literal">
       connect_read_pipe()
      </tt>
      ,
      <tt class="docutils literal">
       connect_write_pipe()
      </tt>
      ,
      <tt class="docutils literal">
       subprocess_shell()
      </tt>
      ,
      <tt class="docutils literal">
       subprocess_exec()
      </tt>
      .
     </li>
     <li>
      Signal callbacks:
      <tt class="docutils literal">
       add_signal_handler()
      </tt>
      ,
      <tt class="docutils literal">
       remove_signal_handler()
      </tt>
      .
     </li>
    </ul>
   </div>
   <div class="section" id="event-loop-methods">
    <h2>
     <a class="toc-backref" href="#id15">
      Event Loop Methods
     </a>
    </h2>
    <div class="section" id="starting-stopping-and-closing">
     <h3>
      <a class="toc-backref" href="#id16">
       Starting, Stopping and Closing
      </a>
     </h3>
     <p>
      An (unclosed) event loop can be in one of two states: running or
stopped.  These methods deal with starting and stopping an event loop:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        run_forever()
       </tt>
       .  Runs the event loop until
       <tt class="docutils literal">
        stop()
       </tt>
       is called.
This cannot be called when the event loop is already running.  (This
has a long name in part to avoid confusion with earlier versions of
this PEP, where
       <tt class="docutils literal">
        run()
       </tt>
       had different behavior, in part because
there are already too many APIs that have a method named
       <tt class="docutils literal">
        run()
       </tt>
       ,
and in part because there shouldn't be many places where this is
called anyway.)
      </li>
      <li>
       <tt class="docutils literal">
        run_until_complete(future)
       </tt>
       .  Runs the event loop until the
Future is done.  If the Future is done, its result is returned, or
its exception is raised.  This cannot be called when the event loop
is already running.
      </li>
      <li>
       <tt class="docutils literal">
        stop()
       </tt>
       .  Stops the event loop as soon as it is convenient.  It
is fine to restart the loop with
       <tt class="docutils literal">
        run_forever()
       </tt>
       or
       <tt class="docutils literal">
        run_until_complete()
       </tt>
       subsequently; no scheduled callbacks will
be lost if this is done.  Note:
       <tt class="docutils literal">
        stop()
       </tt>
       returns normally and the
current callback is allowed to continue.  How soon after this point
the event loop stops is up to the implementation, but the intention
is to stop short of polling for I/O, and not to run any callbacks
scheduled in the future; the major freedom an implementation has is
how much of the "ready queue" (callbacks already scheduled with
       <tt class="docutils literal">
        call_soon()
       </tt>
       ) it processes before stopping.
      </li>
      <li>
       <tt class="docutils literal">
        is_running()
       </tt>
       .  Returns
       <tt class="docutils literal">
        True
       </tt>
       if the event loop is currently
running,
       <tt class="docutils literal">
        False
       </tt>
       if it is stopped.
      </li>
      <li>
       <tt class="docutils literal">
        close()
       </tt>
       .  Closes the event loop, releasing any resources it may
hold, such as the file descriptor used by
       <tt class="docutils literal">
        epoll()
       </tt>
       or
       <tt class="docutils literal">
        kqueue()
       </tt>
       , and the default executor.  This should not be called
while the event loop is running.  After it has been called the event
loop should not be used again.  It may be called multiple times;
subsequent calls are no-ops.
      </li>
     </ul>
    </div>
    <div class="section" id="basic-callbacks">
     <h3>
      <a class="toc-backref" href="#id17">
       Basic Callbacks
      </a>
     </h3>
     <p>
      Callbacks associated with the same event loop are strictly serialized:
one callback must finish before the next one will be called.  This is
an important guarantee: when two or more callbacks use or modify
shared state, each callback is guaranteed that while it is running, the
shared state isn't changed by another callback.
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        call_soon(callback, *args)
       </tt>
       .  This schedules a callback to be
called as soon as possible.  Returns a
       <tt class="docutils literal">
        Handle
       </tt>
       (see below)
representing the callback, whose
       <tt class="docutils literal">
        cancel()
       </tt>
       method can be used to
cancel the callback.  It guarantees that callbacks are called in the
order in which they were scheduled.
      </li>
      <li>
       <tt class="docutils literal">
        call_later(delay, callback, *args)
       </tt>
       .  Arrange for
       <tt class="docutils literal">
        <span class="pre">
         callback(*args)
        </span>
       </tt>
       to be called approximately
       <tt class="docutils literal">
        delay
       </tt>
       seconds in
the future, once, unless cancelled.  Returns a
       <tt class="docutils literal">
        Handle
       </tt>
       representing
the callback, whose
       <tt class="docutils literal">
        cancel()
       </tt>
       method can be used to cancel the
callback.  Callbacks scheduled in the past or at exactly the same
time will be called in an undefined order.
      </li>
      <li>
       <tt class="docutils literal">
        call_at(when, callback, *args)
       </tt>
       .  This is like
       <tt class="docutils literal">
        call_later()
       </tt>
       ,
but the time is expressed as an absolute time.  Returns a similar
       <tt class="docutils literal">
        Handle
       </tt>
       .  There is a simple equivalency:
       <tt class="docutils literal">
        loop.call_later(delay,
callback, *args)
       </tt>
       is the same as
       <tt class="docutils literal">
        loop.call_at(loop.time() +
delay, callback, *args)
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        time()
       </tt>
       .  Returns the current time according to the event loop's
clock.  This may be
       <tt class="docutils literal">
        time.time()
       </tt>
       or
       <tt class="docutils literal">
        time.monotonic()
       </tt>
       or some
other system-specific clock, but it must return a float expressing
the time in units of approximately one second since some epoch.
(No clock is perfect -- see
       <a class="reference external" href="../pep-0418/index.html">
        PEP 418
       </a>
       .)
      </li>
     </ul>
     <p>
      Note: A previous version of this PEP defined a method named
      <tt class="docutils literal">
       call_repeatedly()
      </tt>
      , which promised to call a callback at regular
intervals.  This has been withdrawn because the design of such a
function is overspecified.  On the one hand, a simple timer loop can
easily be emulated using a callback that reschedules itself using
      <tt class="docutils literal">
       call_later()
      </tt>
      ; it is also easy to write coroutine containing a loop
and a
      <tt class="docutils literal">
       sleep()
      </tt>
      call (a toplevel function in the module, see below).
On the other hand, due to the complexities of accurate timekeeping
there are many traps and pitfalls here for the unaware (see
      <a class="reference external" href="../pep-0418/index.html">
       PEP 418
      </a>
      ),
and different use cases require different behavior in edge cases.  It
is impossible to offer an API for this purpose that is bullet-proof in
all cases, so it is deemed better to let application designers decide
for themselves what kind of timer loop to implement.
     </p>
    </div>
    <div class="section" id="thread-interaction">
     <h3>
      <a class="toc-backref" href="#id18">
       Thread interaction
      </a>
     </h3>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        call_soon_threadsafe(callback, *args)
       </tt>
       .  Like
       <tt class="docutils literal">
        call_soon(callback, *args)
       </tt>
       , but when called from another thread
while the event loop is blocked waiting for I/O, unblocks the event
loop.  Returns a
       <tt class="docutils literal">
        Handle
       </tt>
       .  This is the
       <em>
        only
       </em>
       method that is safe
to call from another thread.  (To schedule a callback for a later
time in a threadsafe manner, you can use
       <tt class="docutils literal">
        loop.call_soon_threadsafe(loop.call_later, when, callback,
*args)
       </tt>
       .)  Note: this is not safe to call from a signal handler
(since it may use locks).  In fact, no API is signal-safe; if you
want to handle signals, use
       <tt class="docutils literal">
        add_signal_handler()
       </tt>
       described
below.
      </li>
      <li>
       <tt class="docutils literal">
        run_in_executor(executor, callback, *args)
       </tt>
       .  Arrange to call
       <tt class="docutils literal">
        <span class="pre">
         callback(*args)
        </span>
       </tt>
       in an executor (see
       <a class="reference external" href="../pep-3148/index.html">
        PEP 3148
       </a>
       ).  Returns an
       <tt class="docutils literal">
        asyncio.Future
       </tt>
       instance whose result on success is the return
value of that call.  This is equivalent to
       <tt class="docutils literal">
        wrap_future(executor.submit(callback, *args))
       </tt>
       .  If
       <tt class="docutils literal">
        executor
       </tt>
       is
       <tt class="docutils literal">
        None
       </tt>
       , the default executor set by
       <tt class="docutils literal">
        set_default_executor()
       </tt>
       is used.  If no default executor has been set yet, a
       <tt class="docutils literal">
        ThreadPoolExecutor
       </tt>
       with a default number of threads is created
and set as the default executor.  (The default implementation uses
5 threads in this case.)
      </li>
      <li>
       <tt class="docutils literal">
        set_default_executor(executor)
       </tt>
       .  Set the default executor used
by
       <tt class="docutils literal">
        run_in_executor()
       </tt>
       .  The argument must be a
       <a class="reference external" href="../pep-3148/index.html">
        PEP 3148
       </a>
       <tt class="docutils literal">
        Executor
       </tt>
       instance or
       <tt class="docutils literal">
        None
       </tt>
       , in order to reset the default
executor.
      </li>
     </ul>
     <p>
      See also the
      <tt class="docutils literal">
       wrap_future()
      </tt>
      function described in the section about
Futures.
     </p>
    </div>
    <div class="section" id="internet-name-lookups">
     <h3>
      <a class="toc-backref" href="#id19">
       Internet name lookups
      </a>
     </h3>
     <p>
      These methods are useful if you want to connect or bind a socket to an
address without the risk of blocking for the name lookup.  They are
usually called implicitly by
      <tt class="docutils literal">
       create_connection()
      </tt>
      ,
      <tt class="docutils literal">
       create_server()
      </tt>
      or
      <tt class="docutils literal">
       create_datagram_endpoint()
      </tt>
      .
     </p>
     <ul>
      <li>
       <p class="first">
        <tt class="docutils literal">
         getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)
        </tt>
        .
Similar to the
        <tt class="docutils literal">
         socket.getaddrinfo()
        </tt>
        function but returns a
Future.  The Future's result on success will be a list of the same
format as returned by
        <tt class="docutils literal">
         socket.getaddrinfo()
        </tt>
        , i.e. a list of
        <tt class="docutils literal">
         (address_family, socket_type, socket_protocol, canonical_name,
address)
        </tt>
        where
        <tt class="docutils literal">
         address
        </tt>
        is a 2-tuple
        <tt class="docutils literal">
         (ipv4_address, port)
        </tt>
        for IPv4 addresses and a 4-tuple
        <tt class="docutils literal">
         (ipv4_address, port, flow_info,
scope_id)
        </tt>
        for IPv6 addresses.  If the
        <tt class="docutils literal">
         family
        </tt>
        argument is zero
or unspecified, the list returned may contain a mixture of IPv4 and
IPv6 addresses; otherwise the addresses returned are constrained by
the
        <tt class="docutils literal">
         family
        </tt>
        value (similar for
        <tt class="docutils literal">
         proto
        </tt>
        and
        <tt class="docutils literal">
         flags
        </tt>
        ).  The
default implementation calls
        <tt class="docutils literal">
         socket.getaddrinfo()
        </tt>
        using
        <tt class="docutils literal">
         run_in_executor()
        </tt>
        , but other implementations may choose to
implement their own DNS lookup.  The optional arguments
        <em>
         must
        </em>
        be
specified as keyword arguments.
       </p>
       <p>
        Note: implementations are allowed to implement a subset of the full
socket.getaddrinfo() interface; e.g. they may not support symbolic
port names, or they may ignore or incompletely implement the
        <tt class="docutils literal">
         type
        </tt>
        ,
        <tt class="docutils literal">
         proto
        </tt>
        and
        <tt class="docutils literal">
         flags
        </tt>
        arguments.  However, if
        <tt class="docutils literal">
         type
        </tt>
        and
        <tt class="docutils literal">
         proto
        </tt>
        are ignored, the argument values passed in should be
copied unchanged into the return tuples'
        <tt class="docutils literal">
         socket_type
        </tt>
        and
        <tt class="docutils literal">
         socket_protocol
        </tt>
        elements.  (You can't ignore
        <tt class="docutils literal">
         family
        </tt>
        , since
IPv4 and IPv6 addresses must be looked up differently.  The only
permissible values for
        <tt class="docutils literal">
         family
        </tt>
        are
        <tt class="docutils literal">
         socket.AF_UNSPEC
        </tt>
        (
        <tt class="docutils literal">
         0
        </tt>
        ),
        <tt class="docutils literal">
         socket.AF_INET
        </tt>
        and
        <tt class="docutils literal">
         socket.AF_INET6
        </tt>
        , and the latter only if
it is defined by the platform.)
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         getnameinfo(sockaddr, flags=0)
        </tt>
        .  Similar to
        <tt class="docutils literal">
         socket.getnameinfo()
        </tt>
        but returns a Future.  The Future's result
on success will be a tuple
        <tt class="docutils literal">
         (host, port)
        </tt>
        .  Same implementation
remarks as for
        <tt class="docutils literal">
         getaddrinfo()
        </tt>
        .
       </p>
      </li>
     </ul>
    </div>
    <div class="section" id="internet-connections">
     <h3>
      <a class="toc-backref" href="#id20">
       Internet connections
      </a>
     </h3>
     <p>
      These are the high-level interfaces for managing internet connections.
Their use is recommended over the corresponding lower-level interfaces
because they abstract away the differences between selector-based
and proactor-based event loops.
     </p>
     <p>
      Note that the client and server side of stream connections use the
same transport and protocol interface.  However, datagram endpoints
use a different transport and protocol interface.
     </p>
     <ul>
      <li>
       <p class="first">
        <tt class="docutils literal">
         create_connection(protocol_factory, host, port, &lt;options&gt;)
        </tt>
        .
Creates a stream connection to a given internet host and port.  This
is a task that is typically called from the client side of the
connection.  It creates an implementation-dependent bidirectional
stream Transport to represent the connection, then calls
        <tt class="docutils literal">
         protocol_factory()
        </tt>
        to instantiate (or retrieve) the user's
Protocol implementation, and finally ties the two together.  (See
below for the definitions of Transport and Protocol.)  The user's
Protocol implementation is created or retrieved by calling
        <tt class="docutils literal">
         protocol_factory()
        </tt>
        without arguments(*).  The coroutine's result
on success is the
        <tt class="docutils literal">
         (transport, protocol)
        </tt>
        pair; if a failure
prevents the creation of a successful connection, an appropriate
exception will be raised.  Note that when the coroutine completes,
the protocol's
        <tt class="docutils literal">
         connection_made()
        </tt>
        method has not yet been called;
that will happen when the connection handshake is complete.
       </p>
       <p>
        (*) There is no requirement that
        <tt class="docutils literal">
         protocol_factory
        </tt>
        is a class.
If your protocol class needs to have specific arguments passed to
its constructor, you can use
        <tt class="docutils literal">
         lambda
        </tt>
        .
You can also pass a trivial
        <tt class="docutils literal">
         lambda
        </tt>
        that returns a previously
constructed Protocol instance.
       </p>
       <p>
        The &lt;options&gt; are all specified using optional keyword arguments:
       </p>
       <ul class="simple">
        <li>
         <tt class="docutils literal">
          ssl
         </tt>
         : Pass
         <tt class="docutils literal">
          True
         </tt>
         to create an SSL/TLS transport (by default
a plain TCP transport is created).  Or pass an
         <tt class="docutils literal">
          ssl.SSLContext
         </tt>
         object to override the default SSL context object to be used.  If
a default context is created it is up to the implementation to
configure reasonable defaults.  The reference implementation
currently uses
         <tt class="docutils literal">
          PROTOCOL_SSLv23
         </tt>
         and sets the
         <tt class="docutils literal">
          OP_NO_SSLv2
         </tt>
         option, calls
         <tt class="docutils literal">
          set_default_verify_paths()
         </tt>
         and sets
         <tt class="docutils literal">
          verify_mode
         </tt>
         to
         <tt class="docutils literal">
          CERT_REQUIRED
         </tt>
         .  In addition, whenever the context (default
or otherwise) specifies a
         <tt class="docutils literal">
          verify_mode
         </tt>
         of
         <tt class="docutils literal">
          CERT_REQUIRED
         </tt>
         or
         <tt class="docutils literal">
          CERT_OPTIONAL
         </tt>
         , if a hostname is given, immediately after a
successful handshake
         <tt class="docutils literal">
          ssl.match_hostname(peercert, hostname)
         </tt>
         is
called, and if this raises an exception the conection is closed.
(To avoid this behavior, pass in an SSL context that has
         <tt class="docutils literal">
          verify_mode
         </tt>
         set to
         <tt class="docutils literal">
          CERT_NONE
         </tt>
         .  But this means you are not
secure, and vulnerable to for example man-in-the-middle attacks.)
        </li>
        <li>
         <tt class="docutils literal">
          family
         </tt>
         ,
         <tt class="docutils literal">
          proto
         </tt>
         ,
         <tt class="docutils literal">
          flags
         </tt>
         : Address family, protocol and
flags to be passed through to
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         .  These all
default to
         <tt class="docutils literal">
          0
         </tt>
         , which means "not specified".  (The socket type
is always
         <tt class="docutils literal">
          SOCK_STREAM
         </tt>
         .)  If any of these values are not
specified, the
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         method will choose appropriate
values.  Note:
         <tt class="docutils literal">
          proto
         </tt>
         has nothing to do with the high-level
Protocol concept or the
         <tt class="docutils literal">
          protocol_factory
         </tt>
         argument.
        </li>
        <li>
         <tt class="docutils literal">
          sock
         </tt>
         : An optional socket to be used instead of using the
         <tt class="docutils literal">
          host
         </tt>
         ,
         <tt class="docutils literal">
          port
         </tt>
         ,
         <tt class="docutils literal">
          family
         </tt>
         ,
         <tt class="docutils literal">
          proto
         </tt>
         and
         <tt class="docutils literal">
          flags
         </tt>
         arguments.  If this is given,
         <tt class="docutils literal">
          host
         </tt>
         and
         <tt class="docutils literal">
          port
         </tt>
         must be
explicitly set to
         <tt class="docutils literal">
          None
         </tt>
         .
        </li>
        <li>
         <tt class="docutils literal">
          local_addr
         </tt>
         : If given, a
         <tt class="docutils literal">
          (host, port)
         </tt>
         tuple used to bind
the socket to locally.  This is rarely needed but on multi-homed
servers you occasionally need to force a connection to come from a
specific address.  This is how you would do that.  The host and
port are looked up using
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         .
        </li>
        <li>
         <tt class="docutils literal">
          server_hostname
         </tt>
         : This is only relevant when using SSL/TLS; it
should not be used when
         <tt class="docutils literal">
          ssl
         </tt>
         is not set.  When
         <tt class="docutils literal">
          ssl
         </tt>
         is set,
this sets or overrides the hostname that will be verified.  By
default the value of the
         <tt class="docutils literal">
          host
         </tt>
         argument is used.  If
         <tt class="docutils literal">
          host
         </tt>
         is empty, there is no default and you must pass a value for
         <tt class="docutils literal">
          server_hostname
         </tt>
         .  To disable hostname verification (which is a
serious security risk) you must pass an empty string here and pass
an
         <tt class="docutils literal">
          ssl.SSLContext
         </tt>
         object whose
         <tt class="docutils literal">
          verify_mode
         </tt>
         is set to
         <tt class="docutils literal">
          ssl.CERT_NONE
         </tt>
         as the
         <tt class="docutils literal">
          ssl
         </tt>
         argument.
        </li>
       </ul>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         create_server(protocol_factory, host, port, &lt;options&gt;)
        </tt>
        .
Enters a serving loop that accepts connections.
This is a coroutine that completes once the serving loop is set up
to serve.  The return value is a
        <tt class="docutils literal">
         Server
        </tt>
        object which can be used
to stop the serving loop in a controlled fashion (see below).
Multiple sockets may be bound if the specified address allows
both IPv4 and IPv6 connections.
       </p>
       <p>
        Each time a connection is accepted,
        <tt class="docutils literal">
         protocol_factory
        </tt>
        is called without arguments(**) to create a
Protocol, a bidirectional stream Transport is created to represent
the network side of the connection, and the two are tied together by
calling
        <tt class="docutils literal">
         protocol.connection_made(transport)
        </tt>
        .
       </p>
       <p>
        (**) See previous footnote for
        <tt class="docutils literal">
         create_connection()
        </tt>
        .  However, since
        <tt class="docutils literal">
         protocol_factory()
        </tt>
        is called once for each new incoming
connection, it should return a new Protocol object each time it is
called.
       </p>
       <p>
        The &lt;options&gt; are all specified using optional keyword arguments:
       </p>
       <ul>
        <li>
         <p class="first">
          <tt class="docutils literal">
           ssl
          </tt>
          : Pass an
          <tt class="docutils literal">
           ssl.SSLContext
          </tt>
          object (or an object with the
same interface) to override the default SSL context object to be
used.  (Unlike for
          <tt class="docutils literal">
           create_connection()
          </tt>
          , passing
          <tt class="docutils literal">
           True
          </tt>
          does
not make sense here -- the
          <tt class="docutils literal">
           SSLContext
          </tt>
          object is needed to
specify the certificate and key.)
         </p>
        </li>
        <li>
         <p class="first">
          <tt class="docutils literal">
           backlog
          </tt>
          : Backlog value to be passed to the
          <tt class="docutils literal">
           listen()
          </tt>
          call.
The default is implementation-dependent; in the default
implementation the default value is
          <tt class="docutils literal">
           100
          </tt>
          .
         </p>
        </li>
        <li>
         <p class="first">
          <tt class="docutils literal">
           reuse_address
          </tt>
          : Whether to set the
          <tt class="docutils literal">
           SO_REUSEADDR
          </tt>
          option on
the socket.  The default is
          <tt class="docutils literal">
           True
          </tt>
          on UNIX,
          <tt class="docutils literal">
           False
          </tt>
          on
Windows.
         </p>
        </li>
        <li>
         <dl class="first docutils">
          <dt>
           <tt class="docutils literal">
            family
           </tt>
           ,
           <tt class="docutils literal">
            flags
           </tt>
           : Address family and flags to be passed
          </dt>
          <dd>
           <p class="first last">
            through to
            <tt class="docutils literal">
             getaddrinfo()
            </tt>
            .  The family defaults to
            <tt class="docutils literal">
             AF_UNSPEC
            </tt>
            ; the flags default to
            <tt class="docutils literal">
             AI_PASSIVE
            </tt>
            .  (The socket
type is always
            <tt class="docutils literal">
             SOCK_STREAM
            </tt>
            ; the socket protocol always set to
            <tt class="docutils literal">
             0
            </tt>
            , to let
            <tt class="docutils literal">
             getaddrinfo()
            </tt>
            choose.)
           </p>
          </dd>
         </dl>
        </li>
        <li>
         <p class="first">
          <tt class="docutils literal">
           sock
          </tt>
          : An optional socket to be used instead of using the
          <tt class="docutils literal">
           host
          </tt>
          ,
          <tt class="docutils literal">
           port
          </tt>
          ,
          <tt class="docutils literal">
           family
          </tt>
          and
          <tt class="docutils literal">
           flags
          </tt>
          arguments.  If this
is given,
          <tt class="docutils literal">
           host
          </tt>
          and
          <tt class="docutils literal">
           port
          </tt>
          must be explicitly set to
          <tt class="docutils literal">
           None
          </tt>
          .
         </p>
        </li>
       </ul>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         create_datagram_endpoint(protocol_factory, local_addr=None,
remote_addr=None, &lt;options&gt;)
        </tt>
        .  Creates an endpoint for sending and
receiving datagrams (typically UDP packets).  Because of the nature
of datagram traffic, there are no separate calls to set up client
and server side, since usually a single endpoint acts as both client
and server.  This is a coroutine that returns a
        <tt class="docutils literal">
         (transport,
protocol)
        </tt>
        pair on success, or raises an exception on failure.  If
the coroutine returns successfully, the transport will call
callbacks on the protocol whenever a datagram is received or the
socket is closed; it is up to the protocol to call methods on the
protocol to send datagrams.  The transport returned is a
        <tt class="docutils literal">
         DatagramTransport
        </tt>
        .  The protocol returned is a
        <tt class="docutils literal">
         DatagramProtocol
        </tt>
        .  These are described later.
       </p>
       <p>
        Mandatory positional argument:
       </p>
       <ul class="simple">
        <li>
         <tt class="docutils literal">
          protocol_factory
         </tt>
         : A class or factory function that will be
called exactly once, without arguments, to construct the protocol
object to be returned.  The interface between datagram transport
and protocol is described below.
        </li>
       </ul>
       <p>
        Optional arguments that may be specified positionally or as keyword
arguments:
       </p>
       <ul class="simple">
        <li>
         <tt class="docutils literal">
          local_addr
         </tt>
         : An optional tuple indicating the address to which
the socket will be bound.  If given this must be a
         <tt class="docutils literal">
          (host,
port)
         </tt>
         pair.  It will be passed to
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         to be
resolved and the result will be passed to the
         <tt class="docutils literal">
          bind()
         </tt>
         method of
the socket created.  If
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         returns more than one
address, they will be tried in turn.  If omitted, no
         <tt class="docutils literal">
          bind()
         </tt>
         call will be made.
        </li>
        <li>
         <tt class="docutils literal">
          remote_addr
         </tt>
         : An optional tuple indicating the address to which
the socket will be "connected".  (Since there is no such thing as
a datagram connection, this just specifies a default value for the
destination address of outgoing datagrams.)  If given this must be
a
         <tt class="docutils literal">
          (host, port)
         </tt>
         pair.  It will be passed to
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         to be resolved and the result will be passed to
         <tt class="docutils literal">
          sock_connect()
         </tt>
         together with the socket created.  If
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         returns
more than one address, they will be tried in turn.  If omitted,
no
         <tt class="docutils literal">
          sock_connect()
         </tt>
         call will be made.
        </li>
       </ul>
       <p>
        The &lt;options&gt; are all specified using optional keyword arguments:
       </p>
       <ul class="simple">
        <li>
         <tt class="docutils literal">
          family
         </tt>
         ,
         <tt class="docutils literal">
          proto
         </tt>
         ,
         <tt class="docutils literal">
          flags
         </tt>
         : Address family, protocol and
flags to be passed through to
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         .  These all
default to
         <tt class="docutils literal">
          0
         </tt>
         , which means "not specified".  (The socket type
is always
         <tt class="docutils literal">
          SOCK_DGRAM
         </tt>
         .)  If any of these values are not
specified, the
         <tt class="docutils literal">
          getaddrinfo()
         </tt>
         method will choose appropriate
values.
        </li>
       </ul>
       <p>
        Note that if both
        <tt class="docutils literal">
         local_addr
        </tt>
        and
        <tt class="docutils literal">
         remote_addr
        </tt>
        are present,
all combinations of local and remote addresses with matching address
family will be tried.
       </p>
      </li>
     </ul>
    </div>
    <div class="section" id="wrapped-socket-methods">
     <h3>
      <a class="toc-backref" href="#id21">
       Wrapped Socket Methods
      </a>
     </h3>
     <p>
      The following methods for doing async I/O on sockets are not for
general use.  They are primarily meant for transport implementations
working with IOCP through the
      <tt class="docutils literal">
       ProactorEventLoop
      </tt>
      class.  However,
they are easily implementable for other event loop types, so there is
no reason not to require them.  The socket argument has to be a
non-blocking socket.
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        sock_recv(sock, n)
       </tt>
       .  Receive up to
       <tt class="docutils literal">
        n
       </tt>
       bytes from socket
       <tt class="docutils literal">
        sock
       </tt>
       .  Returns a Future whose result on success will be a
bytes object.
      </li>
      <li>
       <tt class="docutils literal">
        sock_sendall(sock, data)
       </tt>
       .  Send bytes
       <tt class="docutils literal">
        data
       </tt>
       to socket
       <tt class="docutils literal">
        sock
       </tt>
       .  Returns a Future whose result on success will be
       <tt class="docutils literal">
        None
       </tt>
       .  Note: the name uses
       <tt class="docutils literal">
        sendall
       </tt>
       instead of
       <tt class="docutils literal">
        send
       </tt>
       , to
reflect that the semantics and signature of this method echo those
of the standard library socket method
       <tt class="docutils literal">
        sendall()
       </tt>
       rather than
       <tt class="docutils literal">
        send()
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        sock_connect(sock, address)
       </tt>
       .  Connect to the given address.
Returns a Future whose result on success will be
       <tt class="docutils literal">
        None
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        sock_accept(sock)
       </tt>
       .  Accept a connection from a socket.  The
socket must be in listening mode and bound to an address.  Returns a
Future whose result on success will be a tuple
       <tt class="docutils literal">
        (conn, peer)
       </tt>
       where
       <tt class="docutils literal">
        conn
       </tt>
       is a connected non-blocking socket and
       <tt class="docutils literal">
        peer
       </tt>
       is
the peer address.
      </li>
     </ul>
    </div>
    <div class="section" id="i-o-callbacks">
     <h3>
      <a class="toc-backref" href="#id22">
       I/O Callbacks
      </a>
     </h3>
     <p>
      These methods are primarily meant for transport implementations
working with a selector.  They are implemented by
      <tt class="docutils literal">
       SelectorEventLoop
      </tt>
      but not by
      <tt class="docutils literal">
       ProactorEventLoop
      </tt>
      .  Custom event
loop implementations may or may not implement them.
     </p>
     <p>
      The
      <tt class="docutils literal">
       fd
      </tt>
      arguments below may be integer file descriptors, or
"file-like" objects with a
      <tt class="docutils literal">
       fileno()
      </tt>
      method that wrap integer file
descriptors.  Not all file-like objects or file descriptors are
acceptable.  Sockets (and socket file descriptors) are always
accepted.  On Windows no other types are supported.  On UNIX, pipes
and possibly tty devices are also supported, but disk files are not.
Exactly which special file types are supported may vary by platform
and per selector implementation.  (Experimentally, there is at least
one kind of pseudo-tty on OS X that is supported by
      <tt class="docutils literal">
       select
      </tt>
      and
      <tt class="docutils literal">
       poll
      </tt>
      but not by
      <tt class="docutils literal">
       kqueue
      </tt>
      : it is used by Emacs shell windows.)
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        add_reader(fd, callback, *args)
       </tt>
       .  Arrange for
       <tt class="docutils literal">
        <span class="pre">
         callback(*args)
        </span>
       </tt>
       to be called whenever file descriptor
       <tt class="docutils literal">
        fd
       </tt>
       is
deemed ready for reading.  Calling
       <tt class="docutils literal">
        add_reader()
       </tt>
       again for the
same file descriptor implies a call to
       <tt class="docutils literal">
        remove_reader()
       </tt>
       for the
same file descriptor.
      </li>
      <li>
       <tt class="docutils literal">
        add_writer(fd, callback, *args)
       </tt>
       .  Like
       <tt class="docutils literal">
        add_reader()
       </tt>
       ,
but registers the callback for writing instead of for reading.
      </li>
      <li>
       <tt class="docutils literal">
        remove_reader(fd)
       </tt>
       .  Cancels the current read callback for file
descriptor
       <tt class="docutils literal">
        fd
       </tt>
       , if one is set.  If no callback is currently set
for the file descriptor, this is a no-op and returns
       <tt class="docutils literal">
        False
       </tt>
       .
Otherwise, it removes the callback arrangement and returns
       <tt class="docutils literal">
        True
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        remove_writer(fd)
       </tt>
       .  This is to
       <tt class="docutils literal">
        add_writer()
       </tt>
       as
       <tt class="docutils literal">
        remove_reader()
       </tt>
       is to
       <tt class="docutils literal">
        add_reader()
       </tt>
       .
      </li>
     </ul>
    </div>
    <div class="section" id="pipes-and-subprocesses">
     <h3>
      <a class="toc-backref" href="#id23">
       Pipes and Subprocesses
      </a>
     </h3>
     <p>
      These methods are supported by
      <tt class="docutils literal">
       SelectorEventLoop
      </tt>
      on UNIX and
      <tt class="docutils literal">
       ProactorEventLoop
      </tt>
      on Windows.
     </p>
     <p>
      The transports and protocols used with pipes and subprocesses differ
from those used with regular stream connections.  These are described
later.
     </p>
     <p>
      Each of the methods below has a
      <tt class="docutils literal">
       protocol_factory
      </tt>
      argument, similar
to
      <tt class="docutils literal">
       create_connection()
      </tt>
      ; this will be called exactly once, without
arguments, to construct the protocol object to be returned.
     </p>
     <p>
      Each method is a coroutine that returns a
      <tt class="docutils literal">
       (transport, protocol)
      </tt>
      pair on success, or raises an exception on failure.
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        connect_read_pipe(protocol_factory, pipe)
       </tt>
       : Create a
unidrectional stream connection from a file-like object wrapping the
read end of a UNIX pipe, which must be in non-blocking mode.  The
transport returned is a
       <tt class="docutils literal">
        ReadTransport
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        connect_write_pipe(protocol_factory, pipe)
       </tt>
       : Create a
unidrectional stream connection from a file-like object wrapping the
write end of a UNIX pipe, which must be in non-blocking mode.  The
transport returned is a
       <tt class="docutils literal">
        WriteTransport
       </tt>
       ; it does not have any
read-related methods.  The protocol returned is a
       <tt class="docutils literal">
        BaseProtocol
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        subprocess_shell(protocol_factory, cmd, &lt;options&gt;)
       </tt>
       : Create a
subprocess from
       <tt class="docutils literal">
        cmd
       </tt>
       , which is a string using the platform's
"shell" syntax.  This is similar to the standard library
       <tt class="docutils literal">
        subprocess.Popen()
       </tt>
       class called with
       <tt class="docutils literal">
        shell=True
       </tt>
       .  The
remaining arguments and return value are described below.
      </li>
      <li>
       <tt class="docutils literal">
        subprocess_exec(protocol_factory, *args, &lt;options&gt;)
       </tt>
       : Create a
subprocess from one or more string arguments, where the first string
specifies the program to execute, and the remaining strings specify
the program's arguments.  (Thus, together the string arguments form
the
       <tt class="docutils literal">
        sys.argv
       </tt>
       value of the program, assuming it is a Python
script.)  This is similar to the standard library
       <tt class="docutils literal">
        subprocess.Popen()
       </tt>
       class called with
       <tt class="docutils literal">
        shell=False
       </tt>
       and the
list of strings passed as the first argument; however, where
       <tt class="docutils literal">
        Popen()
       </tt>
       takes a single argument which is list of strings,
       <tt class="docutils literal">
        subprocess_exec()
       </tt>
       takes multiple string arguments.  The
remaining arguments and return value are described below.
      </li>
     </ul>
     <p>
      Apart from the way the program to execute is specified, the two
      <tt class="docutils literal">
       <span class="pre">
        subprocess_*()
       </span>
      </tt>
      methods behave the same.  The transport returned is
a
      <tt class="docutils literal">
       SubprocessTransport
      </tt>
      which has a different interface than the
common bidirectional stream transport.  The protocol returned is a
      <tt class="docutils literal">
       SubprocessProtocol
      </tt>
      which also has a custom interface.
     </p>
     <p>
      The &lt;options&gt; are all specified using optional keyword arguments:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        stdin
       </tt>
       : Either a file-like object representing the pipe to be
connected to the subprocess's standard input stream using
       <tt class="docutils literal">
        connect_write_pipe()
       </tt>
       , or the constant
       <tt class="docutils literal">
        subprocess.PIPE
       </tt>
       (the
default).  By default a new pipe will be created and connected.
      </li>
      <li>
       <tt class="docutils literal">
        stdout
       </tt>
       : Either a file-like object representing the pipe to be
connected to the subprocess's standard output stream using
       <tt class="docutils literal">
        connect_read_pipe()
       </tt>
       , or the constant
       <tt class="docutils literal">
        subprocess.PIPE
       </tt>
       (the
default).  By default a new pipe will be created and connected.
      </li>
      <li>
       <tt class="docutils literal">
        stderr
       </tt>
       : Either a file-like object representing the pipe to be
connected to the subprocess's standard error stream using
       <tt class="docutils literal">
        connect_read_pipe()
       </tt>
       , or one of the constants
       <tt class="docutils literal">
        subprocess.PIPE
       </tt>
       (the default) or
       <tt class="docutils literal">
        subprocess.STDOUT
       </tt>
       .  By default a new pipe will
be created and connected.  When
       <tt class="docutils literal">
        subprocess.STDOUT
       </tt>
       is specified,
the subprocess's standard error stream will be connected to the same
pipe as the standard output stream.
      </li>
      <li>
       <tt class="docutils literal">
        bufsize
       </tt>
       : The buffer size to be used when creating a pipe; this
is passed to
       <tt class="docutils literal">
        subprocess.Popen()
       </tt>
       .  In the default implementation
this defaults to zero, and on Windows it must be zero; these
defaults deviate from
       <tt class="docutils literal">
        subprocess.Popen()
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        executable
       </tt>
       ,
       <tt class="docutils literal">
        preexec_fn
       </tt>
       ,
       <tt class="docutils literal">
        close_fds
       </tt>
       ,
       <tt class="docutils literal">
        cwd
       </tt>
       ,
       <tt class="docutils literal">
        env
       </tt>
       ,
       <tt class="docutils literal">
        startupinfo
       </tt>
       ,
       <tt class="docutils literal">
        creationflags
       </tt>
       ,
       <tt class="docutils literal">
        restore_signals
       </tt>
       ,
       <tt class="docutils literal">
        start_new_session
       </tt>
       ,
       <tt class="docutils literal">
        pass_fds
       </tt>
       : These optional arguments are
passed to
       <tt class="docutils literal">
        subprocess.Popen()
       </tt>
       without interpretation.
      </li>
     </ul>
    </div>
    <div class="section" id="signal-callbacks">
     <h3>
      <a class="toc-backref" href="#id24">
       Signal callbacks
      </a>
     </h3>
     <p>
      These methods are only supported on UNIX.
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        add_signal_handler(sig, callback, *args)
       </tt>
       .  Whenever signal
       <tt class="docutils literal">
        sig
       </tt>
       is received, arrange for
       <tt class="docutils literal">
        <span class="pre">
         callback(*args)
        </span>
       </tt>
       to be called.
Specifying another callback for the same signal replaces the
previous handler (only one handler can be active per signal).  The
       <tt class="docutils literal">
        sig
       </tt>
       must be a valid signal number defined in the
       <tt class="docutils literal">
        signal
       </tt>
       module.  If the signal cannot be handled this raises an exception:
       <tt class="docutils literal">
        ValueError
       </tt>
       if it is not a valid signal or if it is an
uncatchable signal (e.g.
       <tt class="docutils literal">
        SIGKILL
       </tt>
       ),
       <tt class="docutils literal">
        RuntimeError
       </tt>
       if this
particular event loop instance cannot handle signals (since signals
are global per process, only an event loop associated with the main
thread can handle signals).
      </li>
      <li>
       <tt class="docutils literal">
        remove_signal_handler(sig)
       </tt>
       .  Removes the handler for signal
       <tt class="docutils literal">
        sig
       </tt>
       , if one is set.  Raises the same exceptions as
       <tt class="docutils literal">
        add_signal_handler()
       </tt>
       (except that it may return
       <tt class="docutils literal">
        False
       </tt>
       instead raising
       <tt class="docutils literal">
        RuntimeError
       </tt>
       for uncatchable signals).  Returns
       <tt class="docutils literal">
        True
       </tt>
       if a handler was removed successfully,
       <tt class="docutils literal">
        False
       </tt>
       if no
handler was set.
      </li>
     </ul>
     <p>
      Note: If these methods are statically known to be unsupported, they
may raise
      <tt class="docutils literal">
       NotImplementedError
      </tt>
      instead of
      <tt class="docutils literal">
       RuntimeError
      </tt>
      .
     </p>
    </div>
   </div>
   <div class="section" id="mutual-exclusion-of-callbacks">
    <h2>
     <a class="toc-backref" href="#id25">
      Mutual Exclusion of Callbacks
     </a>
    </h2>
    <p>
     An event loop should enforce mutual exclusion of callbacks, i.e. it
should never start a callback while a previously callback is still
running.  This should apply across all types of callbacks, regardless
of whether they are scheduled using
     <tt class="docutils literal">
      call_soon()
     </tt>
     ,
     <tt class="docutils literal">
      call_later()
     </tt>
     ,
     <tt class="docutils literal">
      call_at()
     </tt>
     ,
     <tt class="docutils literal">
      call_soon_threadsafe()
     </tt>
     ,
     <tt class="docutils literal">
      add_reader()
     </tt>
     ,
     <tt class="docutils literal">
      add_writer()
     </tt>
     , or
     <tt class="docutils literal">
      add_signal_handler()
     </tt>
     .
    </p>
   </div>
   <div class="section" id="exceptions">
    <h2>
     <a class="toc-backref" href="#id26">
      Exceptions
     </a>
    </h2>
    <p>
     There are two categories of exceptions in Python: those that derive
from the
     <tt class="docutils literal">
      Exception
     </tt>
     class and those that derive from
     <tt class="docutils literal">
      BaseException
     </tt>
     .  Exceptions deriving from
     <tt class="docutils literal">
      Exception
     </tt>
     will
generally be caught and handled appropriately; for example, they will
be passed through by Futures, and they will be logged and ignored when
they occur in a callback.
    </p>
    <p>
     However, exceptions deriving only from
     <tt class="docutils literal">
      BaseException
     </tt>
     are typically
not caught, and will usually cause the program to terminate with a
traceback.  In some cases they are caught and re-raised.  (Examples of
this category include
     <tt class="docutils literal">
      KeyboardInterrupt
     </tt>
     and
     <tt class="docutils literal">
      SystemExit
     </tt>
     ; it is
usually unwise to treat these the same as most other exceptions.)
    </p>
   </div>
   <div class="section" id="handles">
    <h2>
     <a class="toc-backref" href="#id27">
      Handles
     </a>
    </h2>
    <p>
     The various methods for registering one-off callbacks
(
     <tt class="docutils literal">
      call_soon()
     </tt>
     ,
     <tt class="docutils literal">
      call_later()
     </tt>
     ,
     <tt class="docutils literal">
      call_at()
     </tt>
     and
     <tt class="docutils literal">
      call_soon_threadsafe()
     </tt>
     ) all return an object representing the
registration that can be used to cancel the callback.  This object is
called a
     <tt class="docutils literal">
      Handle
     </tt>
     .  Handles are opaque and have only one public
method:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       cancel()
      </tt>
      : Cancel the callback.
     </li>
    </ul>
    <p>
     Note that
     <tt class="docutils literal">
      add_reader()
     </tt>
     ,
     <tt class="docutils literal">
      add_writer()
     </tt>
     and
     <tt class="docutils literal">
      add_signal_handler()
     </tt>
     do not return Handles.
    </p>
   </div>
   <div class="section" id="servers">
    <h2>
     <a class="toc-backref" href="#id28">
      Servers
     </a>
    </h2>
    <p>
     The
     <tt class="docutils literal">
      create_server()
     </tt>
     method returns a
     <tt class="docutils literal">
      Server
     </tt>
     instance, which
wraps the sockets (or other network objects) used to accept requests.
This class has two public methods:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       close()
      </tt>
      : Close the service.  This stops accepting new requests
but does not cancel requests that have already been accepted and are
currently being handled.
     </li>
     <li>
      <tt class="docutils literal">
       wait_closed()
      </tt>
      : A coroutine that blocks until the service is
closed and all accepted requests have been handled.
     </li>
    </ul>
   </div>
   <div class="section" id="futures">
    <h2>
     <a class="toc-backref" href="#id29">
      Futures
     </a>
    </h2>
    <p>
     The
     <tt class="docutils literal">
      asyncio.Future
     </tt>
     class here is intentionally similar to the
     <tt class="docutils literal">
      concurrent.futures.Future
     </tt>
     class specified by
     <a class="reference external" href="../pep-3148/index.html">
      PEP 3148
     </a>
     , but there
are slight differences.  Whenever this PEP talks about Futures or
futures this should be understood to refer to
     <tt class="docutils literal">
      asyncio.Future
     </tt>
     unless
     <tt class="docutils literal">
      concurrent.futures.Future
     </tt>
     is explicitly mentioned.  The supported
public API is as follows, indicating the differences with
     <a class="reference external" href="../pep-3148/index.html">
      PEP 3148
     </a>
     :
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       cancel()
      </tt>
      .  If the Future is already done (or cancelled), do
nothing and return
      <tt class="docutils literal">
       False
      </tt>
      .  Otherwise, this attempts to cancel
the Future and returns
      <tt class="docutils literal">
       True
      </tt>
      .  If the the cancellation attempt is
successful, eventually the Future's state will change to cancelled
(so that
      <tt class="docutils literal">
       cancelled()
      </tt>
      will return
      <tt class="docutils literal">
       True
      </tt>
      )
and the callbacks will be scheduled.  For regular Futures,
cancellation will always succeed immediately; but for Tasks (see
below) the task may ignore or delay the cancellation attempt.
     </li>
     <li>
      <tt class="docutils literal">
       cancelled()
      </tt>
      .  Returns
      <tt class="docutils literal">
       True
      </tt>
      if the Future was successfully
cancelled.
     </li>
     <li>
      <tt class="docutils literal">
       done()
      </tt>
      .  Returns
      <tt class="docutils literal">
       True
      </tt>
      if the Future is done.  Note that a
cancelled Future is considered done too (here and everywhere).
     </li>
     <li>
      <tt class="docutils literal">
       result()
      </tt>
      .  Returns the result set with
      <tt class="docutils literal">
       set_result()
      </tt>
      , or
raises the exception set with
      <tt class="docutils literal">
       set_exception()
      </tt>
      .  Raises
      <tt class="docutils literal">
       CancelledError
      </tt>
      if cancelled.  Difference with
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      : This has
no timeout argument and does
      <em>
       not
      </em>
      wait; if the future is not yet
done, it raises an exception.
     </li>
     <li>
      <tt class="docutils literal">
       exception()
      </tt>
      .  Returns the exception if set with
      <tt class="docutils literal">
       set_exception()
      </tt>
      , or
      <tt class="docutils literal">
       None
      </tt>
      if a result was set with
      <tt class="docutils literal">
       set_result()
      </tt>
      .  Raises
      <tt class="docutils literal">
       CancelledError
      </tt>
      if cancelled.
Difference with
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      : This has no timeout argument and does
      <em>
       not
      </em>
      wait; if the future is not yet done, it raises an exception.
     </li>
     <li>
      <tt class="docutils literal">
       add_done_callback(fn)
      </tt>
      .  Add a callback to be run when the Future
becomes done (or is cancelled).  If the Future is already done (or
cancelled), schedules the callback to using
      <tt class="docutils literal">
       call_soon()
      </tt>
      .
Difference with
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      : The callback is never called immediately,
and always in the context of the caller -- typically this is a
thread.  You can think of this as calling the callback through
      <tt class="docutils literal">
       call_soon()
      </tt>
      .  Note that in order to match
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      , the callback
(unlike all other callbacks defined in this PEP, and ignoring the
convention from the section "Callback Style" below) is always called
with a single argument, the Future object.  (The motivation for
strictly serializing callbacks scheduled with
      <tt class="docutils literal">
       call_soon()
      </tt>
      applies here too.)
     </li>
     <li>
      <tt class="docutils literal">
       remove_done_callback(fn)
      </tt>
      .  Remove the argument from the list of
callbacks.  This method is not defined by
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      .  The argument
must be equal (using
      <tt class="docutils literal">
       ==
      </tt>
      ) to the argument passed to
      <tt class="docutils literal">
       add_done_callback()
      </tt>
      .  Returns the number of times the callback
was removed.
     </li>
     <li>
      <tt class="docutils literal">
       set_result(result)
      </tt>
      .  The Future must not be done (nor cancelled)
already.  This makes the Future done and schedules the callbacks.
Difference with
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      : This is a public API.
     </li>
     <li>
      <tt class="docutils literal">
       set_exception(exception)
      </tt>
      .  The Future must not be done (nor
cancelled) already.  This makes the Future done and schedules the
callbacks.  Difference with
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      : This is a public API.
     </li>
    </ul>
    <p>
     The internal method
     <tt class="docutils literal">
      set_running_or_notify_cancel()
     </tt>
     is not
supported; there is no way to set the running state.  Likewise,
the method
     <tt class="docutils literal">
      running()
     </tt>
     is not supported.
    </p>
    <p>
     The following exceptions are defined:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       InvalidStateError
      </tt>
      .  Raised whenever the Future is not in a state
acceptable to the method being called (e.g. calling
      <tt class="docutils literal">
       set_result()
      </tt>
      on a Future that is already done, or calling
      <tt class="docutils literal">
       result()
      </tt>
      on a Future
that is not yet done).
     </li>
     <li>
      <tt class="docutils literal">
       InvalidTimeoutError
      </tt>
      .  Raised by
      <tt class="docutils literal">
       result()
      </tt>
      and
      <tt class="docutils literal">
       exception()
      </tt>
      when a nonzero
      <tt class="docutils literal">
       timeout
      </tt>
      argument is given.
     </li>
     <li>
      <tt class="docutils literal">
       CancelledError
      </tt>
      .  An alias for
      <tt class="docutils literal">
       concurrent.futures.CancelledError
      </tt>
      .  Raised when
      <tt class="docutils literal">
       result()
      </tt>
      or
      <tt class="docutils literal">
       exception()
      </tt>
      is called on a Future that is cancelled.
     </li>
     <li>
      <tt class="docutils literal">
       TimeoutError
      </tt>
      .  An alias for
      <tt class="docutils literal">
       concurrent.futures.TimeoutError
      </tt>
      .
May be raised by
      <tt class="docutils literal">
       run_until_complete()
      </tt>
      .
     </li>
    </ul>
    <p>
     A Future is associated with an event loop when it is created.
    </p>
    <p>
     A
     <tt class="docutils literal">
      asyncio.Future
     </tt>
     object is not acceptable to the
     <tt class="docutils literal">
      wait()
     </tt>
     and
     <tt class="docutils literal">
      as_completed()
     </tt>
     functions in the
     <tt class="docutils literal">
      concurrent.futures
     </tt>
     package.
However, there are similar APIs
     <tt class="docutils literal">
      asyncio.wait()
     </tt>
     and
     <tt class="docutils literal">
      asyncio.as_completed()
     </tt>
     , described below.
    </p>
    <p>
     A
     <tt class="docutils literal">
      asyncio.Future
     </tt>
     object is acceptable to a
     <tt class="docutils literal">
      yield from
     </tt>
     expression
when used in a coroutine.  This is implemented through the
     <tt class="docutils literal">
      __iter__()
     </tt>
     interface on the Future.  See the section "Coroutines
and the Scheduler" below.
    </p>
    <p>
     When a Future is garbage-collected, if it has an associated exception
but neither
     <tt class="docutils literal">
      result()
     </tt>
     nor
     <tt class="docutils literal">
      exception()
     </tt>
     has ever been called, the
exception is logged.  (When a coroutine uses
     <tt class="docutils literal">
      yield from
     </tt>
     to wait
for a Future, that Future's
     <tt class="docutils literal">
      result()
     </tt>
     method is called once the
coroutine is resumed.)
    </p>
    <p>
     In the future (pun intended) we may unify
     <tt class="docutils literal">
      asyncio.Future
     </tt>
     and
     <tt class="docutils literal">
      concurrent.futures.Future
     </tt>
     , e.g. by adding an
     <tt class="docutils literal">
      __iter__()
     </tt>
     method
to the latter that works with
     <tt class="docutils literal">
      yield from
     </tt>
     .  To prevent accidentally
blocking the event loop by calling e.g.
     <tt class="docutils literal">
      result()
     </tt>
     on a Future
that's not done yet, the blocking operation may detect that an event
loop is active in the current thread and raise an exception instead.
However the current PEP strives to have no dependencies beyond Python
3.3, so changes to
     <tt class="docutils literal">
      concurrent.futures.Future
     </tt>
     are off the table for
now.
    </p>
    <p>
     There are some public functions related to Futures:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       asyncio.async(arg)
      </tt>
      .  This takes an argument that is either a
coroutine object or a Future (i.e., anything you can use with
      <tt class="docutils literal">
       yield from
      </tt>
      ) and returns a Future.  If the argument is a Future,
it is returned unchanged; if it is a coroutine object, it wraps it
in a Task (remember that
      <tt class="docutils literal">
       Task
      </tt>
      is a subclass of
      <tt class="docutils literal">
       Future
      </tt>
      ).
     </li>
     <li>
      <tt class="docutils literal">
       asyncio.wrap_future(future)
      </tt>
      .  This takes a
      <a class="reference external" href="../pep-3148/index.html">
       PEP 3148
      </a>
      Future
(i.e., an instance of
      <tt class="docutils literal">
       concurrent.futures.Future
      </tt>
      ) and returns a
Future compatible with the event loop (i.e., a
      <tt class="docutils literal">
       asyncio.Future
      </tt>
      instance).
     </li>
    </ul>
   </div>
   <div class="section" id="transports">
    <h2>
     <a class="toc-backref" href="#id30">
      Transports
     </a>
    </h2>
    <p>
     Transports and protocols are strongly influenced by Twisted and
     <a class="reference external" href="../pep-3153/index.html">
      PEP
3153
     </a>
     .  Users rarely implement or instantiate transports -- rather,
event loops offer utility methods to set up transports.
    </p>
    <p>
     Transports work in conjunction with protocols.  Protocols are
typically written without knowing or caring about the exact type of
transport used, and transports can be used with a wide variety of
protocols.  For example, an HTTP client protocol implementation may be
used with either a plain socket transport or an SSL/TLS transport.
The plain socket transport can be used with many different protocols
besides HTTP (e.g. SMTP, IMAP, POP, FTP, IRC, SPDY).
    </p>
    <p>
     The most common type of transport is a bidirectional stream transport.
There are also unidirectional stream transports (used for pipes) and
datagram transports (used by the
     <tt class="docutils literal">
      create_datagram_endpoint()
     </tt>
     method).
    </p>
    <div class="section" id="methods-for-all-transports">
     <h3>
      <a class="toc-backref" href="#id31">
       Methods For All Transports
      </a>
     </h3>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        get_extra_info(name, default=None)
       </tt>
       .  This is a catch-all method
that returns implementation-specific information about a transport.
The first argument is the name of the extra field to be retrieved.
The optional second argument is a default value to be returned.
Consult the implementation documentation to find out the supported
extra field names.  For an unsupported name, the default is always
returned.
      </li>
     </ul>
    </div>
    <div class="section" id="bidirectional-stream-transports">
     <h3>
      <a class="toc-backref" href="#id32">
       Bidirectional Stream Transports
      </a>
     </h3>
     <p>
      A bidrectional stream transport is an abstraction on top of a socket
or something similar (for example, a pair of UNIX pipes or an SSL/TLS
connection).
     </p>
     <p>
      Most connections have an asymmetric nature: the client and server
usually have very different roles and behaviors.  Hence, the interface
between transport and protocol is also asymmetric.  From the
protocol's point of view,
      <em>
       writing
      </em>
      data is done by calling the
      <tt class="docutils literal">
       write()
      </tt>
      method on the transport object; this buffers the data and
returns immediately.  However, the transport takes a more active role
in
      <em>
       reading
      </em>
      data: whenever some data is read from the socket (or
other data source), the transport calls the protocol's
      <tt class="docutils literal">
       data_received()
      </tt>
      method.
     </p>
     <p>
      Nevertheless, the interface between transport and protocol used by
bidirectional streams is the same for clients as it is for servers,
since the connection between a client and a server is essentially a
pair of streams, one in each direction.
     </p>
     <p>
      Bidirectional stream transports have the following public methods:
     </p>
     <ul>
      <li>
       <p class="first">
        <tt class="docutils literal">
         write(data)
        </tt>
        .  Write some bytes.  The argument must be a bytes
object.  Returns
        <tt class="docutils literal">
         None
        </tt>
        .  The transport is free to buffer the
bytes, but it must eventually cause the bytes to be transferred to
the entity at the other end, and it must maintain stream behavior.
That is,
        <tt class="docutils literal">
         <span class="pre">
          t.write(b'abc');
         </span>
         t.write(b'def')
        </tt>
        is equivalent to
        <tt class="docutils literal">
         t.write(b'abcdef')
        </tt>
        , as well as to:
       </p>
       <pre class="literal-block">
t.write(b'a')
t.write(b'b')
t.write(b'c')
t.write(b'd')
t.write(b'e')
t.write(b'f')
</pre>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         writelines(iterable)
        </tt>
        .  Equivalent to:
       </p>
       <pre class="literal-block">
for data in iterable:
    self.write(data)
</pre>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         write_eof()
        </tt>
        .  Close the writing end of the connection.
Subsequent calls to
        <tt class="docutils literal">
         write()
        </tt>
        are not allowed.  Once all buffered
data is transferred, the transport signals to the other end that no
more data will be received.  Some protocols don't support this
operation; in that case, calling
        <tt class="docutils literal">
         write_eof()
        </tt>
        will raise an
exception.  (Note: This used to be called
        <tt class="docutils literal">
         half_close()
        </tt>
        , but
unless you already know what it is for, that name doesn't indicate
        <em>
         which
        </em>
        end is closed.)
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         can_write_eof()
        </tt>
        .  Return
        <tt class="docutils literal">
         True
        </tt>
        if the protocol supports
        <tt class="docutils literal">
         write_eof()
        </tt>
        ,
        <tt class="docutils literal">
         False
        </tt>
        if it does not.  (This method typically
returns a fixed value that depends only on the specific Transport
class, not on the state of the Transport object.  It is needed
because some protocols need to change their behavior when
        <tt class="docutils literal">
         write_eof()
        </tt>
        is unavailable.  For example, in HTTP, to send data
whose size is not known ahead of time, the end of the data is
typically indicated using
        <tt class="docutils literal">
         write_eof()
        </tt>
        ; however, SSL/TLS does not
support this, and an HTTP protocol implementation would have to use
the "chunked" transfer encoding in this case.  But if the data size
is known ahead of time, the best approach in both cases is to use
the Content-Length header.)
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         get_write_buffer_size()
        </tt>
        .  Return the current size of the
transport's write buffer in bytes.  This only knows about the write
buffer managed explicitly by the transport; buffering in other
layers of the network stack or elsewhere of the network is not
reported.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         set_write_buffer_limits(high=None, low=None)
        </tt>
        .  Set the high- and
low-water limits for flow control.
       </p>
       <p>
        These two values control when to call the protocol's
        <tt class="docutils literal">
         pause_writing()
        </tt>
        and
        <tt class="docutils literal">
         resume_writing()
        </tt>
        methods.  If specified,
the low-water limit must be less than or equal to the high-water
limit.  Neither value can be negative.
       </p>
       <p>
        The defaults are implementation-specific.  If only the high-water
limit is given, the low-water limit defaults to a
implementation-specific value less than or equal to the high-water
limit.  Setting high to zero forces low to zero as well, and causes
        <tt class="docutils literal">
         pause_writing()
        </tt>
        to be called whenever the buffer becomes
non-empty.  Setting low to zero causes
        <tt class="docutils literal">
         resume_writing()
        </tt>
        to be
called only once the buffer is empty.  Use of zero for either limit
is generally sub-optimal as it reduces opportunities for doing I/O
and computation concurrently.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         pause_reading()
        </tt>
        .  Suspend delivery of data to the protocol until
a subsequent
        <tt class="docutils literal">
         resume_reading()
        </tt>
        call.  Between
        <tt class="docutils literal">
         pause_reading()
        </tt>
        and
        <tt class="docutils literal">
         resume_reading()
        </tt>
        , the protocol's
        <tt class="docutils literal">
         data_received()
        </tt>
        method
will not be called.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         resume_reading()
        </tt>
        .  Restart delivery of data to the protocol via
        <tt class="docutils literal">
         data_received()
        </tt>
        .  Note that "paused" is a binary state --
        <tt class="docutils literal">
         pause_reading()
        </tt>
        should only be called when the transport is not
paused, while
        <tt class="docutils literal">
         resume_reading()
        </tt>
        should only be called when the
transport is paused.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         close()
        </tt>
        .  Sever the connection with the entity at the other end.
Any data buffered by
        <tt class="docutils literal">
         write()
        </tt>
        will (eventually) be transferred
before the connection is actually closed.  The protocol's
        <tt class="docutils literal">
         data_received()
        </tt>
        method will not be called again.  Once all
buffered data has been flushed, the protocol's
        <tt class="docutils literal">
         connection_lost()
        </tt>
        method will be called with
        <tt class="docutils literal">
         None
        </tt>
        as the argument.  Note that
this method does not wait for all that to happen.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         abort()
        </tt>
        .  Immediately sever the connection.  Any data still
buffered by the transport is thrown away.  Soon, the protocol's
        <tt class="docutils literal">
         connection_lost()
        </tt>
        method will be called with
        <tt class="docutils literal">
         None
        </tt>
        as
argument.
       </p>
      </li>
     </ul>
    </div>
    <div class="section" id="unidirectional-stream-transports">
     <h3>
      <a class="toc-backref" href="#id33">
       Unidirectional Stream Transports
      </a>
     </h3>
     <p>
      A writing stream transport supports the
      <tt class="docutils literal">
       write()
      </tt>
      ,
      <tt class="docutils literal">
       writelines()
      </tt>
      ,
      <tt class="docutils literal">
       write_eof()
      </tt>
      ,
      <tt class="docutils literal">
       can_write_eof()
      </tt>
      , close() and
      <tt class="docutils literal">
       abort()
      </tt>
      methods
described for bidrectional stream transports.
     </p>
     <p>
      A reading stream transport supports the
      <tt class="docutils literal">
       pause_reading()
      </tt>
      ,
      <tt class="docutils literal">
       resume_reading()
      </tt>
      and
      <tt class="docutils literal">
       close()
      </tt>
      methods described for
bidrectional stream transports.
     </p>
     <p>
      A writing stream transport calls only
      <tt class="docutils literal">
       connection_made()
      </tt>
      and
      <tt class="docutils literal">
       connection_lost()
      </tt>
      on its associated protocol.
     </p>
     <p>
      A reading stream transport can call all protocol methods specified in
the Protocols section below (i.e., the previous two plus
      <tt class="docutils literal">
       data_received()
      </tt>
      and
      <tt class="docutils literal">
       eof_received()
      </tt>
      ).
     </p>
    </div>
    <div class="section" id="datagram-transports">
     <h3>
      <a class="toc-backref" href="#id34">
       Datagram Transports
      </a>
     </h3>
     <p>
      Datagram transports have these methods:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        sendto(data, addr=None)
       </tt>
       .  Sends a datagram (a bytes object).
The optional second argument is the destination address.  If
omitted,
       <tt class="docutils literal">
        remote_addr
       </tt>
       must have been specified in the
       <tt class="docutils literal">
        create_datagram_endpoint()
       </tt>
       call that created this transport.  If
present, and
       <tt class="docutils literal">
        remote_addr
       </tt>
       was specified, they must match.  The
(data, addr) pair may be sent immediately or buffered.  The return
value is
       <tt class="docutils literal">
        None
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        abort()
       </tt>
       .  Immediately close the transport.  Buffered data will
be discarded.
      </li>
      <li>
       <tt class="docutils literal">
        close()
       </tt>
       .  Close the transport.  Buffered data will be
transmitted asynchronously.
      </li>
     </ul>
     <p>
      Datagram transports call the following methods on the associated
protocol object:
      <tt class="docutils literal">
       connection_made()
      </tt>
      ,
      <tt class="docutils literal">
       connection_lost()
      </tt>
      ,
      <tt class="docutils literal">
       error_received()
      </tt>
      and
      <tt class="docutils literal">
       datagram_received()
      </tt>
      .  ("Connection"
in these method names is a slight misnomer, but the concepts still
exist:
      <tt class="docutils literal">
       connection_made()
      </tt>
      means the transport representing the
endpoint has been created, and
      <tt class="docutils literal">
       connection_lost()
      </tt>
      means the
transport is closed.)
     </p>
    </div>
    <div class="section" id="subprocess-transports">
     <h3>
      <a class="toc-backref" href="#id35">
       Subprocess Transports
      </a>
     </h3>
     <p>
      Subprocess transports have the following methods:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        get_pid()
       </tt>
       .  Return the process ID of the subprocess.
      </li>
      <li>
       <tt class="docutils literal">
        get_returncode()
       </tt>
       .  Return the process return code, if the
process has exited; otherwise
       <tt class="docutils literal">
        None
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        get_pipe_transport(fd)
       </tt>
       .  Return the pipe transport (a
unidirectional stream transport) corresponding to the argument,
which should be 0, 1 or 2 representing stdin, stdout or stderr (of
the subprocess).  If there is no such pipe transport, return
       <tt class="docutils literal">
        None
       </tt>
       .  For stdin, this is a writing transport; for stdout and
stderr this is a reading transport.  You must use this method to get
a transport you can use to write to the subprocess's stdin.
      </li>
      <li>
       <tt class="docutils literal">
        send_signal(signal)
       </tt>
       .  Send a signal to the subprocess.
      </li>
      <li>
       <tt class="docutils literal">
        terminate()
       </tt>
       .  Terminate the subprocess.
      </li>
      <li>
       <tt class="docutils literal">
        kill()
       </tt>
       .  Kill the subprocess.  On Windows this is an alias for
       <tt class="docutils literal">
        terminate()
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        close()
       </tt>
       .  This is an alias for
       <tt class="docutils literal">
        terminate()
       </tt>
       .
      </li>
     </ul>
     <p>
      Note that
      <tt class="docutils literal">
       send_signal()
      </tt>
      ,
      <tt class="docutils literal">
       terminate()
      </tt>
      and
      <tt class="docutils literal">
       kill()
      </tt>
      wrap the
corresponding methods in the standard library
      <tt class="docutils literal">
       subprocess
      </tt>
      module.
     </p>
    </div>
   </div>
   <div class="section" id="protocols">
    <h2>
     <a class="toc-backref" href="#id36">
      Protocols
     </a>
    </h2>
    <p>
     Protocols are always used in conjunction with transports.  While a few
common protocols are provided (e.g. decent though not necessarily
excellent HTTP client and server implementations), most protocols will
be implemented by user code or third-party libraries.
    </p>
    <p>
     Like for transports, we distinguish between stream protocols, datagram
protocols, and perhaps other custom protocols.  The most common type
of protocol is a bidirectional stream protocol.  (There are no
unidirectional protocols.)
    </p>
    <div class="section" id="stream-protocols">
     <h3>
      <a class="toc-backref" href="#id37">
       Stream Protocols
      </a>
     </h3>
     <p>
      A (bidirectional) stream protocol must implement the following
methods, which will be called by the transport.  Think of these as
callbacks that are always called by the event loop in the right
context.  (See the "Context" section way above.)
     </p>
     <ul>
      <li>
       <p class="first">
        <tt class="docutils literal">
         connection_made(transport)
        </tt>
        .  Indicates that the transport is
ready and connected to the entity at the other end.  The protocol
should probably save the transport reference as an instance variable
(so it can call its
        <tt class="docutils literal">
         write()
        </tt>
        and other methods later), and may
write an initial greeting or request at this point.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         data_received(data)
        </tt>
        .  The transport has read some bytes from the
connection.  The argument is always a non-empty bytes object.  There
are no guarantees about the minimum or maximum size of the data
passed along this way.
        <tt class="docutils literal">
         p.data_received(b'abcdef')
        </tt>
        should be
treated exactly equivalent to:
       </p>
       <pre class="literal-block">
p.data_received(b'abc')
p.data_received(b'def')
</pre>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         eof_received()
        </tt>
        .  This is called when the other end called
        <tt class="docutils literal">
         write_eof()
        </tt>
        (or something equivalent).  If this returns a false
value (including
        <tt class="docutils literal">
         None
        </tt>
        ), the transport will close itself.  If it
returns a true value, closing the transport is up to the protocol.
However, for SSL/TLS connections this is ignored, because the TLS
standard requires that no more data is sent and the connection is
closed as soon as a "closure alert" is received.
       </p>
       <p>
        The default implementation returns
        <tt class="docutils literal">
         None
        </tt>
        .
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         pause_writing()
        </tt>
        .  Asks that the protocol temporarily stop
writing data to the transport.  Heeding the request is optional, but
the transport's buffer may grow without bounds if you keep writing.
The buffer size at which this is called can be controlled through
the transport's
        <tt class="docutils literal">
         set_write_buffer_limits()
        </tt>
        method.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         resume_writing()
        </tt>
        .  Tells the protocol that it is safe to start
writing data to the transport again.  Note that this may be called
directly by the transport's
        <tt class="docutils literal">
         write()
        </tt>
        method (as opposed to being
called indirectly using
        <tt class="docutils literal">
         call_soon()
        </tt>
        ), so that the protocol may
be aware of its paused state immediately after
        <tt class="docutils literal">
         write()
        </tt>
        returns.
       </p>
      </li>
      <li>
       <p class="first">
        <tt class="docutils literal">
         connection_lost(exc)
        </tt>
        .  The transport has been closed or aborted,
has detected that the other end has closed the connection cleanly,
or has encountered an unexpected error.  In the first three cases
the argument is
        <tt class="docutils literal">
         None
        </tt>
        ; for an unexpected error, the argument is
the exception that caused the transport to give up.
       </p>
      </li>
     </ul>
     <p>
      Here is a table indicating the order and multiplicity of the basic
calls:
     </p>
     <blockquote>
      <ol class="arabic simple">
       <li>
        <tt class="docutils literal">
         connection_made()
        </tt>
        -- exactly once
       </li>
       <li>
        <tt class="docutils literal">
         data_received()
        </tt>
        -- zero or more times
       </li>
       <li>
        <tt class="docutils literal">
         eof_received()
        </tt>
        -- at most once
       </li>
       <li>
        <tt class="docutils literal">
         connection_lost()
        </tt>
        -- exactly once
       </li>
      </ol>
     </blockquote>
     <p>
      Calls to
      <tt class="docutils literal">
       pause_writing()
      </tt>
      and
      <tt class="docutils literal">
       resume_writing()
      </tt>
      occur in pairs
and only between #1 and #4.  These pairs will not be nested.  The
final
      <tt class="docutils literal">
       resume_writing()
      </tt>
      call may be omitted; i.e. a paused
connection may be lost and never be resumed.
     </p>
    </div>
    <div class="section" id="datagram-protocols">
     <h3>
      <a class="toc-backref" href="#id38">
       Datagram Protocols
      </a>
     </h3>
     <p>
      Datagram protocols have
      <tt class="docutils literal">
       connection_made()
      </tt>
      and
      <tt class="docutils literal">
       connection_lost()
      </tt>
      methods with the same signatures as stream
protocols.  (As explained in the section about datagram transports, we
prefer the slightly odd nomenclature over defining different method
names to indicating the opening and closing of the socket.)
     </p>
     <p>
      In addition, they have the following methods:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        datagram_received(data, addr)
       </tt>
       .  Indicates that a datagram
       <tt class="docutils literal">
        data
       </tt>
       (a bytes objects) was received from remote address
       <tt class="docutils literal">
        addr
       </tt>
       (an IPv4 2-tuple or an IPv6 4-tuple).
      </li>
      <li>
       <tt class="docutils literal">
        error_received(exc)
       </tt>
       .  Indicates that a send or receive operation
raised an
       <tt class="docutils literal">
        OSError
       </tt>
       exception.  Since datagram errors may be
transient, it is up to the protocol to call the transport's
       <tt class="docutils literal">
        close()
       </tt>
       method if it wants to close the endpoint.
      </li>
     </ul>
     <p>
      Here is a chart indicating the order and multiplicity of calls:
     </p>
     <blockquote>
      <ol class="arabic simple">
       <li>
        <tt class="docutils literal">
         connection_made()
        </tt>
        -- exactly once
       </li>
       <li>
        <tt class="docutils literal">
         datagram_received()
        </tt>
        ,
        <tt class="docutils literal">
         error_received()
        </tt>
        -- zero or more times
       </li>
       <li>
        <tt class="docutils literal">
         connection_lost()
        </tt>
        -- exactly once
       </li>
      </ol>
     </blockquote>
    </div>
    <div class="section" id="subprocess-protocol">
     <h3>
      <a class="toc-backref" href="#id39">
       Subprocess Protocol
      </a>
     </h3>
     <p>
      Subprocess protocols have
      <tt class="docutils literal">
       connection_made()
      </tt>
      ,
      <tt class="docutils literal">
       connection_lost()
      </tt>
      ,
      <tt class="docutils literal">
       pause_writing()
      </tt>
      and
      <tt class="docutils literal">
       resume_writing()
      </tt>
      methods with the same
signatures as stream protocols.  In addition, they have the following
methods:
     </p>
     <ul class="simple">
      <li>
       <tt class="docutils literal">
        pipe_data_received(fd, data)
       </tt>
       .  Called when the subprocess writes
data to its stdout or stderr.
       <tt class="docutils literal">
        fd
       </tt>
       is the file descriptor (1 for
stdout, 2 for stderr).
       <tt class="docutils literal">
        data
       </tt>
       is a
       <tt class="docutils literal">
        bytes
       </tt>
       object.  (TBD: No
       <tt class="docutils literal">
        pipe_eof_received()
       </tt>
       ?)
      </li>
      <li>
       <tt class="docutils literal">
        pipe_connection_lost(fd, exc)
       </tt>
       .  Called when the subprocess
closes its stdin, stdout or stderr.
       <tt class="docutils literal">
        fd
       </tt>
       is the file descriptor.
       <tt class="docutils literal">
        exc
       </tt>
       is an exception or
       <tt class="docutils literal">
        None
       </tt>
       .
      </li>
      <li>
       <tt class="docutils literal">
        process_exited()
       </tt>
       .  Called when the subprocess has exited.  To
retrieve the exit status, use the transport's
       <tt class="docutils literal">
        get_returncode()
       </tt>
       method.
      </li>
     </ul>
     <p>
      Note that depending on the behavior of the subprocess it is possible
that
      <tt class="docutils literal">
       process_exited()
      </tt>
      is called either before or after
      <tt class="docutils literal">
       pipe_connection_lost()
      </tt>
      .  For example, if the subprocess creates a
sub-subprocess that shares its stdin/stdout/stderr and then itself
exits,
      <tt class="docutils literal">
       process_exited()
      </tt>
      may be called while all the pipes are
still open.  On the other hand when the subprocess closes its
stdin/stdout/stderr but does not exit,
      <tt class="docutils literal">
       pipe_connection_lost()
      </tt>
      may
be called for all three pipes without
      <tt class="docutils literal">
       process_exited()
      </tt>
      being
called.  If (as is the more common case) the subprocess exits and
thereby implicitly closes all pipes, the calling order is undefined.
     </p>
    </div>
   </div>
   <div class="section" id="callback-style">
    <h2>
     <a class="toc-backref" href="#id40">
      Callback Style
     </a>
    </h2>
    <p>
     Most interfaces taking a callback also take positional arguments.  For
instance, to arrange for
     <tt class="docutils literal">
      <span class="pre">
       foo("abc",
      </span>
      42)
     </tt>
     to be called soon, you
call
     <tt class="docutils literal">
      loop.call_soon(foo, "abc", 42)
     </tt>
     .  To schedule the call
     <tt class="docutils literal">
      foo()
     </tt>
     , use
     <tt class="docutils literal">
      loop.call_soon(foo)
     </tt>
     .  This convention greatly
reduces the number of small lambdas required in typical callback
programming.
    </p>
    <p>
     This convention specifically does
     <em>
      not
     </em>
     support keyword arguments.
Keyword arguments are used to pass optional extra information about
the callback.  This allows graceful evolution of the API without
having to worry about whether a keyword might be significant to a
callee somewhere.  If you have a callback that
     <em>
      must
     </em>
     be called with a
keyword argument, you can use a lambda.  For example:
    </p>
    <pre class="literal-block">
loop.call_soon(lambda: foo('abc', repeat=42))
</pre>
   </div>
  </div>
  <div class="section" id="coroutines-and-the-scheduler">
   <h1>
    <a class="toc-backref" href="#id41">
     Coroutines and the Scheduler
    </a>
   </h1>
   <p>
    This is a separate toplevel section because its status is different
from the event loop interface.  Usage of coroutines is optional, and
it is perfectly fine to write code using callbacks only.  On the other
hand, there is only one implementation of the scheduler/coroutine API,
and if you're using coroutines, that's the one you're using.
   </p>
   <div class="section" id="coroutines">
    <h2>
     <a class="toc-backref" href="#id42">
      Coroutines
     </a>
    </h2>
    <p>
     A coroutine is a generator that follows certain conventions.  For
documentation purposes, all coroutines should be decorated with
     <tt class="docutils literal">
      @asyncio.coroutine
     </tt>
     , but this cannot be strictly enforced.
    </p>
    <p>
     Coroutines use the
     <tt class="docutils literal">
      yield from
     </tt>
     syntax introduced in
     <a class="reference external" href="../pep-0380/index.html">
      PEP 380
     </a>
     ,
instead of the original
     <tt class="docutils literal">
      yield
     </tt>
     syntax.
    </p>
    <p>
     The word "coroutine", like the word "generator", is used for two
different (though related) concepts:
    </p>
    <ul class="simple">
     <li>
      The function that defines a coroutine (a function definition
decorated with
      <tt class="docutils literal">
       asyncio.coroutine
      </tt>
      ).  If disambiguation is needed
we will call this a
      <em>
       coroutine function
      </em>
      .
     </li>
     <li>
      The object obtained by calling a coroutine function.  This object
represents a computation or an I/O operation (usually a combination)
that will complete eventually.  If disambiguation is needed we will
call it a
      <em>
       coroutine object
      </em>
      .
     </li>
    </ul>
    <p>
     Things a coroutine can do:
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       result = yield from future
      </tt>
      -- suspends the coroutine until the
future is done, then returns the future's result, or raises an
exception, which will be propagated.  (If the future is cancelled,
it will raise a
      <tt class="docutils literal">
       CancelledError
      </tt>
      exception.)  Note that tasks are
futures, and everything said about futures also applies to tasks.
     </li>
     <li>
      <tt class="docutils literal">
       result = yield from coroutine
      </tt>
      -- wait for another coroutine to
produce a result (or raise an exception, which will be propagated).
The
      <tt class="docutils literal">
       coroutine
      </tt>
      expression must be a
      <em>
       call
      </em>
      to another coroutine.
     </li>
     <li>
      <tt class="docutils literal">
       return expression
      </tt>
      -- produce a result to the coroutine that is
waiting for this one using
      <tt class="docutils literal">
       yield from
      </tt>
      .
     </li>
     <li>
      <tt class="docutils literal">
       raise exception
      </tt>
      -- raise an exception in the coroutine that is
waiting for this one using
      <tt class="docutils literal">
       yield from
      </tt>
      .
     </li>
    </ul>
    <p>
     Calling a coroutine does not start its code running -- it is just a
generator, and the coroutine object returned by the call is really a
generator object, which doesn't do anything until you iterate over it.
In the case of a coroutine object, there are two basic ways to start
it running: call
     <tt class="docutils literal">
      yield from coroutine
     </tt>
     from another coroutine
(assuming the other coroutine is already running!), or convert it to a
Task (see below).
    </p>
    <p>
     Coroutines (and tasks) can only run when the event loop is running.
    </p>
   </div>
   <div class="section" id="waiting-for-multiple-coroutines">
    <h2>
     <a class="toc-backref" href="#id43">
      Waiting for Multiple Coroutines
     </a>
    </h2>
    <p>
     To wait for multiple coroutines or Futures, two APIs similar to the
     <tt class="docutils literal">
      wait()
     </tt>
     and
     <tt class="docutils literal">
      as_completed()
     </tt>
     APIs in the
     <tt class="docutils literal">
      concurrent.futures
     </tt>
     package are provided:
    </p>
    <ul>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.wait(fs, timeout=None, return_when=ALL_COMPLETED)
       </tt>
       .  This
is a coroutine that waits for the Futures or coroutines given by
       <tt class="docutils literal">
        fs
       </tt>
       to complete.  Coroutine arguments will be wrapped in Tasks
(see below).  This returns a Future whose result on success is a
tuple of two sets of Futures,
       <tt class="docutils literal">
        (done, pending)
       </tt>
       , where
       <tt class="docutils literal">
        done
       </tt>
       is
the set of original Futures (or wrapped coroutines) that are done
(or cancelled), and
       <tt class="docutils literal">
        pending
       </tt>
       is the rest, i.e. those that are
still not done (nor cancelled).  Note that with the defaults for
       <tt class="docutils literal">
        timeout
       </tt>
       and
       <tt class="docutils literal">
        return_when
       </tt>
       ,
       <tt class="docutils literal">
        done
       </tt>
       will always be an empty
list.  Optional arguments
       <tt class="docutils literal">
        timeout
       </tt>
       and
       <tt class="docutils literal">
        return_when
       </tt>
       have the
same meaning and defaults as for
       <tt class="docutils literal">
        concurrent.futures.wait()
       </tt>
       :
       <tt class="docutils literal">
        timeout
       </tt>
       , if not
       <tt class="docutils literal">
        None
       </tt>
       , specifies a timeout for the overall
operation;
       <tt class="docutils literal">
        return_when
       </tt>
       , specifies when to stop.  The constants
       <tt class="docutils literal">
        FIRST_COMPLETED
       </tt>
       ,
       <tt class="docutils literal">
        FIRST_EXCEPTION
       </tt>
       ,
       <tt class="docutils literal">
        ALL_COMPLETED
       </tt>
       are
defined with the same values and the same meanings as in
       <a class="reference external" href="../pep-3148/index.html">
        PEP 3148
       </a>
       :
      </p>
      <ul class="simple">
       <li>
        <tt class="docutils literal">
         ALL_COMPLETED
        </tt>
        (default): Wait until all Futures are done (or
until the timeout occurs).
       </li>
       <li>
        <tt class="docutils literal">
         FIRST_COMPLETED
        </tt>
        : Wait until at least one Future is done (or
until the timeout occurs).
       </li>
       <li>
        <tt class="docutils literal">
         FIRST_EXCEPTION
        </tt>
        : Wait until at least one Future is done but
not cancelled with an exception set.  (The exclusion of cancelled
Futures from the condition is surprising, but
        <a class="reference external" href="../pep-3148/index.html">
         PEP 3148
        </a>
        does it
this way.)
       </li>
      </ul>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.as_completed(fs, timeout=None)
       </tt>
       .  Returns an iterator whose
values are Futures or coroutines; waiting for successive values
waits until the next Future or coroutine from the set
       <tt class="docutils literal">
        fs
       </tt>
       completes, and returns its result (or raises its exception).  The
optional argument
       <tt class="docutils literal">
        timeout
       </tt>
       has the same meaning and default as it
does for
       <tt class="docutils literal">
        concurrent.futures.wait()
       </tt>
       : when the timeout occurs, the
next Future returned by the iterator will raise
       <tt class="docutils literal">
        TimeoutError
       </tt>
       when waited for.  Example of use:
      </p>
      <pre class="literal-block">
for f in as_completed(fs):
    result = yield from f  # May raise an exception.
    # Use result.
</pre>
      <p>
       Note: if you do not wait for the values produced by the iterator,
your
       <tt class="docutils literal">
        for
       </tt>
       loop may not make progress (since you are not allowing
other tasks to run).
      </p>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.wait_for(f, timeout)
       </tt>
       .  This is a convenience to wait for
a single coroutine or Future with a timeout.  When a timeout occurs,
it cancels the task and raises TimeoutError.  To avoid the task
cancellation, wrap it in shield().
      </p>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.gather(f1, f2,
        <span class="pre">
         ...)
        </span>
       </tt>
       .  Returns a Future which waits until
all arguments (Futures or coroutines) are done and return a list of
their corresponding results.  If one or more of the arguments is
cancelled or raises an exception, the returned Future is cancelled
or has its exception set (matching what happened to the first
argument), and the remaining arguments are left running in the
background.  Cancelling the returned Future does not affect the
arguments.  Note that coroutine arguments are converted to Futures
using
       <tt class="docutils literal">
        asyncio.async()
       </tt>
       .
      </p>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.shield(f)
       </tt>
       .  Wait for a Future, shielding it from
cancellation.  This returns a Future whose result or exception
is exactly the same as the argument; however, if the returned
Future is cancelled, the argument Future is unaffected.
      </p>
      <p>
       A use case for this function would be a coroutine that caches a
query result for a coroutine that handles a request in an HTTP
server.  When the request is cancelled by the client, we could
(arguably) want the query-caching coroutine to continue to run, so
that when the client reconnects, the query result is (hopefully)
cached.  This could be written e.g. as follows:
      </p>
      <pre class="literal-block">
@asyncio.coroutine
def handle_request(self, request):
    ...
    cached_query = self.get_cache(...)
    if cached_query is None:
        cached_query = yield from asyncio.shield(self.fill_cache(...))
    ...
</pre>
     </li>
    </ul>
   </div>
   <div class="section" id="sleeping">
    <h2>
     <a class="toc-backref" href="#id44">
      Sleeping
     </a>
    </h2>
    <p>
     The coroutine
     <tt class="docutils literal">
      asyncio.sleep(delay)
     </tt>
     returns after a given time delay.
    </p>
   </div>
   <div class="section" id="tasks">
    <h2>
     <a class="toc-backref" href="#id45">
      Tasks
     </a>
    </h2>
    <p>
     A Task is an object that manages an independently running coroutine.
The Task interface is the same as the Future interface, and in fact
     <tt class="docutils literal">
      Task
     </tt>
     is a subclass of
     <tt class="docutils literal">
      Future
     </tt>
     .  The task becomes done when its
coroutine returns or raises an exception; if it returns a result, that
becomes the task's result, if it raises an exception, that becomes the
task's exception.
    </p>
    <p>
     Cancelling a task that's not done yet throws an
     <tt class="docutils literal">
      asyncio.CancelledError
     </tt>
     exception into the coroutine.  If the
coroutine doesn't catch this (or if it re-raises it) the task will be
marked as cancelled (i.e.,
     <tt class="docutils literal">
      cancelled()
     </tt>
     will return
     <tt class="docutils literal">
      True
     </tt>
     ); but
if the coroutine somehow catches and ignores the exception it may
continue to execute (and
     <tt class="docutils literal">
      cancelled()
     </tt>
     will return
     <tt class="docutils literal">
      False
     </tt>
     ).
    </p>
    <p>
     Tasks are also useful for interoperating between coroutines and
callback-based frameworks like Twisted.  After converting a coroutine
into a Task, callbacks can be added to the Task.
    </p>
    <p>
     To convert a coroutine into a task, call the coroutine function and
pass the resulting coroutine object to the
     <tt class="docutils literal">
      asyncio.Task()
     </tt>
     constructor.  You may also use
     <tt class="docutils literal">
      asyncio.async()
     </tt>
     for this purpose.
    </p>
    <p>
     You may ask, why not automatically convert all coroutines to Tasks?
The
     <tt class="docutils literal">
      @asyncio.coroutine
     </tt>
     decorator could do this.  However, this would
slow things down considerably in the case where one coroutine calls
another (and so on), as switching to a "bare" coroutine has much less
overhead than switching to a Task.
    </p>
   </div>
   <div class="section" id="the-scheduler">
    <h2>
     <a class="toc-backref" href="#id46">
      The Scheduler
     </a>
    </h2>
    <p>
     The scheduler has no public interface.  You interact with it by using
     <tt class="docutils literal">
      yield from future
     </tt>
     and
     <tt class="docutils literal">
      yield from task
     </tt>
     .  In fact, there is no
single object representing the scheduler -- its behavior is
implemented by the
     <tt class="docutils literal">
      Task
     </tt>
     and
     <tt class="docutils literal">
      Future
     </tt>
     classes using only the
public interface of the event loop, so it will work with third-party
event loop implementations, too.
    </p>
   </div>
   <div class="section" id="convenience-utilities">
    <h2>
     <a class="toc-backref" href="#id47">
      Convenience Utilities
     </a>
    </h2>
    <p>
     A few functions and classes are provided to simplify the writing of
basic stream-based clients and servers, such as FTP or HTTP.  Thes
are:
    </p>
    <ul>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.open_connection(host, port)
       </tt>
       : A wrapper for
       <tt class="docutils literal">
        EventLoop.create_connection()
       </tt>
       that does not require you to
provide a
       <tt class="docutils literal">
        Protocol
       </tt>
       factory or class.  This is a coroutine that
returns a
       <tt class="docutils literal">
        (reader, writer)
       </tt>
       pair, where
       <tt class="docutils literal">
        reader
       </tt>
       is an instance
of
       <tt class="docutils literal">
        StreamReader
       </tt>
       and
       <tt class="docutils literal">
        writer
       </tt>
       is an instance of
       <tt class="docutils literal">
        StreamWriter
       </tt>
       (both described below).
      </p>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        asyncio.start_server(client_connected_cb, host, port)
       </tt>
       : A wrapper
for
       <tt class="docutils literal">
        EventLoop.create_server()
       </tt>
       that takes a simple callback
function rather than a
       <tt class="docutils literal">
        Protocol
       </tt>
       factory or class.  This is a
coroutine that returns a
       <tt class="docutils literal">
        Server
       </tt>
       object just as
       <tt class="docutils literal">
        create_server()
       </tt>
       does.  Each time a client connection is
accepted,
       <tt class="docutils literal">
        client_connected_cb(reader, writer)
       </tt>
       is called, where
       <tt class="docutils literal">
        reader
       </tt>
       is an instance of
       <tt class="docutils literal">
        StreamReader
       </tt>
       and
       <tt class="docutils literal">
        writer
       </tt>
       is an
instance of
       <tt class="docutils literal">
        StreamWriter
       </tt>
       (both described below).  If the result
returned by
       <tt class="docutils literal">
        client_connected_cb()
       </tt>
       is a coroutine, it is
automatically wrapped in a
       <tt class="docutils literal">
        Task
       </tt>
       .
      </p>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        StreamReader
       </tt>
       : A class offering an interface not unlike that of a
read-only binary stream, except that the various reading methods are
coroutines.  It is normally driven by a
       <tt class="docutils literal">
        StreamReaderProtocol
       </tt>
       instance.  Note that there should be only one reader.  The interface
for the reader is:
      </p>
      <ul class="simple">
       <li>
        <tt class="docutils literal">
         readline()
        </tt>
        : A coroutine that reads a string of bytes
representing a line of text ending in
        <tt class="docutils literal">
         '\n'
        </tt>
        , or until the end
of the stream, whichever comes first.
       </li>
       <li>
        <tt class="docutils literal">
         read(n)
        </tt>
        : A coroutine that reads up to
        <tt class="docutils literal">
         n
        </tt>
        bytes.  If
        <tt class="docutils literal">
         n
        </tt>
        is omitted or negative, it reads until the end of the stream.
       </li>
       <li>
        <tt class="docutils literal">
         readexactly(n)
        </tt>
        : A coroutine that reads exactly
        <tt class="docutils literal">
         n
        </tt>
        bytes, or
until the end of the stream, whichever comes first.
       </li>
       <li>
        <tt class="docutils literal">
         exception()
        </tt>
        : Return the exception that has been set on the
stream using
        <tt class="docutils literal">
         set_exception()
        </tt>
        , or None if no exception is set.
       </li>
      </ul>
      <p>
       The interface for the driver is:
      </p>
      <ul class="simple">
       <li>
        <tt class="docutils literal">
         feed_data(data)
        </tt>
        : Append
        <tt class="docutils literal">
         data
        </tt>
        (a
        <tt class="docutils literal">
         bytes
        </tt>
        object) to the
internal buffer.  This unblocks a blocked reading coroutine if it
provides sufficient data to fulfill the reader's contract.
       </li>
       <li>
        <tt class="docutils literal">
         feed_eof()
        </tt>
        : Signal the end of the buffer.  This unblocks a
blocked reading coroutine.  No more data should be fed to the
reader after this call.
       </li>
       <li>
        <tt class="docutils literal">
         set_exception(exc)
        </tt>
        : Set an exception on the stream.  All
subsequent reading methods will raise this exception.  No more
data should be fed to the reader after this call.
       </li>
      </ul>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        StreamWriter
       </tt>
       : A class offering an interface not unlike that of a
write-only binary stream.  It wraps a transport.  The interface is
an extended subset of the transport interface: the following methods
behave the same as the corresponding transport methods:
       <tt class="docutils literal">
        write()
       </tt>
       ,
       <tt class="docutils literal">
        writelines()
       </tt>
       ,
       <tt class="docutils literal">
        write_eof()
       </tt>
       ,
       <tt class="docutils literal">
        can_write_eof()
       </tt>
       ,
       <tt class="docutils literal">
        get_extra_info()
       </tt>
       ,
       <tt class="docutils literal">
        close()
       </tt>
       .  Note that the writing methods
are _not_ coroutines (this is the same as for transports, but
different from the
       <tt class="docutils literal">
        StreamReader
       </tt>
       class).  The following method is
in addition to the transport interface:
      </p>
      <ul>
       <li>
        <p class="first">
         <tt class="docutils literal">
          drain()
         </tt>
         : This should be called with
         <tt class="docutils literal">
          yield from
         </tt>
         after
writing significant data, for the purpose of flow control.  The
intended use is like this:
        </p>
        <pre class="literal-block">
writer.write(data)
yield from writer.drain()
</pre>
        <p>
         Note that this is not technically a coroutine: it returns either a
Future or an empty tuple (both can be passed to
         <tt class="docutils literal">
          yield from
         </tt>
         ).
Use of this method is optional.  However, when it is not used, the
internal buffer of the transport underlying the
         <tt class="docutils literal">
          StreamWriter
         </tt>
         may fill up with all data that was ever written to the writer.  If
an app does not have a strict limit on how much data it writes, it
_should_ call
         <tt class="docutils literal">
          yield from drain()
         </tt>
         occasionally to avoid filling
up the transport buffer.
        </p>
       </li>
      </ul>
     </li>
     <li>
      <p class="first">
       <tt class="docutils literal">
        StreamReaderProtocol
       </tt>
       : A protocol implementation used as an
adapter between the bidirectional stream transport/protocol
interface and the
       <tt class="docutils literal">
        StreamReader
       </tt>
       and
       <tt class="docutils literal">
        StreamWriter
       </tt>
       classes.  It
acts as a driver for a specific
       <tt class="docutils literal">
        StreamReader
       </tt>
       instance, calling
its methods
       <tt class="docutils literal">
        feed_data()
       </tt>
       ,
       <tt class="docutils literal">
        feed_eof()
       </tt>
       , and
       <tt class="docutils literal">
        set_exception()
       </tt>
       in response to various protocol callbacks.  It also controls the
behavior of the
       <tt class="docutils literal">
        drain()
       </tt>
       method of the
       <tt class="docutils literal">
        StreamWriter
       </tt>
       instance.
      </p>
     </li>
    </ul>
   </div>
  </div>
  <div class="section" id="synchronization">
   <h1>
    <a class="toc-backref" href="#id48">
     Synchronization
    </a>
   </h1>
   <p>
    Locks, events, conditions and semaphores modeled after those in the
    <tt class="docutils literal">
     threading
    </tt>
    module are implemented and can be accessed by importing
the
    <tt class="docutils literal">
     asyncio.locks
    </tt>
    submodule.  Queus modeled after those in the
    <tt class="docutils literal">
     queue
    </tt>
    module are implemented and can be accessed by importing the
    <tt class="docutils literal">
     asyncio.queues
    </tt>
    submodule.
   </p>
   <p>
    In general these have a close correspondence to their threaded
counterparts, however, blocking methods (e.g.
    <tt class="docutils literal">
     acquire()
    </tt>
    on locks,
    <tt class="docutils literal">
     put()
    </tt>
    and
    <tt class="docutils literal">
     get()
    </tt>
    on queues) are coroutines, and timeout
parameters are not provided (you can use
    <tt class="docutils literal">
     asyncio.wait_for()
    </tt>
    to add
a timeout to a blocking call, however).
   </p>
   <p>
    The docstrings in the modules provide more complete documentation.
   </p>
   <div class="section" id="locks">
    <h2>
     <a class="toc-backref" href="#id49">
      Locks
     </a>
    </h2>
    <p>
     The following classes are provided by
     <tt class="docutils literal">
      asyncio.locks
     </tt>
     .  For all
these except
     <tt class="docutils literal">
      Event
     </tt>
     , the
     <tt class="docutils literal">
      with
     </tt>
     statement may be used in
combination with
     <tt class="docutils literal">
      yield from
     </tt>
     to acquire the lock and ensure that
the lock is released regardless of how the
     <tt class="docutils literal">
      with
     </tt>
     block is left, as
follows:
    </p>
    <pre class="literal-block">
with (yield from my_lock):
    ...
</pre>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       Lock
      </tt>
      : a basic mutex, with methods
      <tt class="docutils literal">
       acquire()
      </tt>
      (a coroutine),
      <tt class="docutils literal">
       locked()
      </tt>
      , and
      <tt class="docutils literal">
       release()
      </tt>
      .
     </li>
     <li>
      <tt class="docutils literal">
       Event
      </tt>
      : an event variable, with methods
      <tt class="docutils literal">
       wait()
      </tt>
      (a coroutine),
      <tt class="docutils literal">
       set()
      </tt>
      ,
      <tt class="docutils literal">
       clear()
      </tt>
      , and
      <tt class="docutils literal">
       is_set()
      </tt>
      .
     </li>
     <li>
      <tt class="docutils literal">
       Condition
      </tt>
      : a condition variable, with methods
      <tt class="docutils literal">
       acquire()
      </tt>
      ,
      <tt class="docutils literal">
       wait()
      </tt>
      ,
      <tt class="docutils literal">
       wait_for(predicate)
      </tt>
      (all three coroutines),
      <tt class="docutils literal">
       locked()
      </tt>
      ,
      <tt class="docutils literal">
       release()
      </tt>
      ,
      <tt class="docutils literal">
       notify()
      </tt>
      , and
      <tt class="docutils literal">
       notify_all()
      </tt>
      .
     </li>
     <li>
      <tt class="docutils literal">
       Semaphore
      </tt>
      : a semaphore, with methods
      <tt class="docutils literal">
       acquire()
      </tt>
      (a
coroutine),
      <tt class="docutils literal">
       locked()
      </tt>
      , and
      <tt class="docutils literal">
       release()
      </tt>
      .  The constructor
argument is the initial value (default
      <tt class="docutils literal">
       1
      </tt>
      ).
     </li>
     <li>
      <tt class="docutils literal">
       BoundedSemaphore
      </tt>
      : a bounded semaphore; this is similar to
      <tt class="docutils literal">
       Semaphore
      </tt>
      but the initial value is also the maximum value.
     </li>
    </ul>
   </div>
   <div class="section" id="queues">
    <h2>
     <a class="toc-backref" href="#id50">
      Queues
     </a>
    </h2>
    <p>
     The following classes and exceptions are provided by
     <tt class="docutils literal">
      asyncio.queues
     </tt>
     .
    </p>
    <ul class="simple">
     <li>
      <tt class="docutils literal">
       Queue
      </tt>
      : a standard queue, with methods
      <tt class="docutils literal">
       get()
      </tt>
      ,
      <tt class="docutils literal">
       put()
      </tt>
      (both
coroutines),
      <tt class="docutils literal">
       get_nowait()
      </tt>
      ,
      <tt class="docutils literal">
       put_nowait()
      </tt>
      ,
      <tt class="docutils literal">
       empty()
      </tt>
      ,
      <tt class="docutils literal">
       full()
      </tt>
      ,
      <tt class="docutils literal">
       qsize()
      </tt>
      , and
      <tt class="docutils literal">
       maxsize()
      </tt>
      .
     </li>
     <li>
      <tt class="docutils literal">
       PriorityQueue
      </tt>
      : a subclass of
      <tt class="docutils literal">
       Queue
      </tt>
      that retrieves entries
in priority order (lowest first).
     </li>
     <li>
      <tt class="docutils literal">
       LifoQueue
      </tt>
      : a subclass of
      <tt class="docutils literal">
       Queue
      </tt>
      that retrieves the most
recently added entries first.
     </li>
     <li>
      <tt class="docutils literal">
       JoinableQueue
      </tt>
      : a subclass of
      <tt class="docutils literal">
       Queue
      </tt>
      with
      <tt class="docutils literal">
       task_done()
      </tt>
      and
      <tt class="docutils literal">
       join()
      </tt>
      methods (the latter a coroutine).
     </li>
     <li>
      <tt class="docutils literal">
       Empty
      </tt>
      ,
      <tt class="docutils literal">
       Full
      </tt>
      : exceptions raised when
      <tt class="docutils literal">
       get_nowait()
      </tt>
      or
      <tt class="docutils literal">
       put_nowait()
      </tt>
      is called on a queue that is empty or full,
respectively.
     </li>
    </ul>
   </div>
  </div>
  <div class="section" id="miscellaneous">
   <h1>
    <a class="toc-backref" href="#id51">
     Miscellaneous
    </a>
   </h1>
   <div class="section" id="logging">
    <h2>
     <a class="toc-backref" href="#id52">
      Logging
     </a>
    </h2>
    <p>
     All logging performed by the
     <tt class="docutils literal">
      asyncio
     </tt>
     package uses a single
     <tt class="docutils literal">
      logging.Logger
     </tt>
     object,
     <tt class="docutils literal">
      asyncio.logger
     </tt>
     .  To customize logging
you can use the standard
     <tt class="docutils literal">
      Logger
     </tt>
     API on this object.  (Do not
replace the object though.)
    </p>
   </div>
   <div class="section" id="sigchld-handling-on-unix">
    <h2>
     <a class="toc-backref" href="#id53">
      <tt class="docutils literal">
       SIGCHLD
      </tt>
      handling on UNIX
     </a>
    </h2>
    <p>
     Efficient implementation of the
     <tt class="docutils literal">
      process_exited()
     </tt>
     method on
subprocess protocols requires a
     <tt class="docutils literal">
      SIGCHLD
     </tt>
     signal handler.  However,
signal handlers can only be set on the event loop associated with the
main thread.  In order to support spawning subprocesses from event
loops running in other threads, a mechanism exists to allow sharing a
     <tt class="docutils literal">
      SIGCHLD
     </tt>
     handler between multiple event loops.  There are two
additional functions,
     <tt class="docutils literal">
      asyncio.get_child_watcher()
     </tt>
     and
     <tt class="docutils literal">
      asyncio.set_child_watcher()
     </tt>
     , and corresponding methods on the
event loop policy.
    </p>
    <p>
     There are two child watcher implementation classes,
     <tt class="docutils literal">
      FastChildWatcher
     </tt>
     and
     <tt class="docutils literal">
      SafeChildWatcher
     </tt>
     .  Both use
     <tt class="docutils literal">
      SIGCHLD
     </tt>
     .
The
     <tt class="docutils literal">
      SafeChildWatcher
     </tt>
     class is used by default; it is inefficient
when many subprocesses exist simultaneously.  The
     <tt class="docutils literal">
      FastChildWatcher
     </tt>
     class is efficient, but it may interfere with other code (either C
code or Python code) that spawns subprocesses without using an
     <tt class="docutils literal">
      asyncio
     </tt>
     event loop.  If you are sure you are not using other code
that spawns subprocesses, to use the fast implementation, run the
following in your main thread:
    </p>
    <pre class="literal-block">
watcher = asyncio.FastChildWatcher()
asyncio.set_child_watcher(watcher)
</pre>
   </div>
  </div>
  <div class="section" id="wish-list">
   <h1>
    <a class="toc-backref" href="#id54">
     Wish List
    </a>
   </h1>
   <p>
    (There is agreement that these features are desirable, but no
implementation was available when Python 3.4 beta 1 was released, and
the feature freeze for the rest of the Python 3.4 release cycle
prohibits adding them in this late stage.  However, they will
hopefully be added in Python 3.5, and perhaps earlier in the PyPI
distribution.)
   </p>
   <ul class="simple">
    <li>
     Support a "start TLS" operation to upgrade a TCP socket to SSL/TLS.
    </li>
   </ul>
   <p>
    Former wish list items that have since been implemented (but aren't
specified by the PEP):
   </p>
   <ul class="simple">
    <li>
     UNIX domain sockets.
    </li>
    <li>
     A per-loop error handling callback.
    </li>
   </ul>
  </div>
  <div class="section" id="open-issues">
   <h1>
    <a class="toc-backref" href="#id55">
     Open Issues
    </a>
   </h1>
   <p>
    (Note that these have been resolved de facto in favor of the status
quo by the acceptance of the PEP.  However, the PEP's provisional
status allows revising these decisions for Python 3.5.)
   </p>
   <ul class="simple">
    <li>
     Why do
     <tt class="docutils literal">
      create_connection()
     </tt>
     and
     <tt class="docutils literal">
      create_datagram_endpoint()
     </tt>
     have a
     <tt class="docutils literal">
      proto
     </tt>
     argument but not
     <tt class="docutils literal">
      create_server()
     </tt>
     ?  And why are
the family, flag, proto arguments for
     <tt class="docutils literal">
      getaddrinfo()
     </tt>
     sometimes
zero and sometimes named constants (whose value is also zero)?
    </li>
    <li>
     Do we need another inquiry method to tell whether the loop is in the
process of stopping?
    </li>
    <li>
     A fuller public API for Handle?  What's the use case?
    </li>
    <li>
     A debugging API?  E.g. something that logs a lot of stuff, or logs
unusual conditions (like queues filling up faster than they drain)
or even callbacks taking too much time...
    </li>
    <li>
     Do we need introspection APIs?  E.g. asking for the read callback
given a file descriptor.  Or when the next scheduled call is.  Or
the list of file descriptors registered with callbacks.  Right now
these all require using internals.
    </li>
    <li>
     Do we need more socket I/O methods, e.g.
     <tt class="docutils literal">
      sock_sendto()
     </tt>
     and
     <tt class="docutils literal">
      sock_recvfrom()
     </tt>
     , and perhaps others like
     <tt class="docutils literal">
      pipe_read()
     </tt>
     ?
I guess users can write their own (it's not rocket science).
    </li>
    <li>
     We may need APIs to control various timeouts.  E.g. we may want to
limit the time spent in DNS resolution, connecting, ssl/tls handshake,
idle connection, close/shutdown, even per session.  Possibly it's
sufficient to add
     <tt class="docutils literal">
      timeout
     </tt>
     keyword arguments to some methods,
and other timeouts can probably be implemented by clever use of
     <tt class="docutils literal">
      call_later()
     </tt>
     and
     <tt class="docutils literal">
      Task.cancel()
     </tt>
     .  But it's possible that some
operations need default timeouts, and we may want to change the
default for a specific operation globally (i.e., per event loop).
    </li>
   </ul>
  </div>
  <div class="section" id="references">
   <h1>
    <a class="toc-backref" href="#id56">
     References
    </a>
   </h1>
   <ul class="simple">
    <li>
     <a class="reference external" href="../pep-0380/index.html">
      PEP 380
     </a>
     describes the semantics of
     <tt class="docutils literal">
      yield from
     </tt>
     .
    </li>
    <li>
     Greg Ewing's
     <tt class="docutils literal">
      yield from
     </tt>
     tutorials:
     <a class="reference external" href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html">
      http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html
     </a>
    </li>
    <li>
     <a class="reference external" href="../pep-3148/index.html">
      PEP 3148
     </a>
     describes
     <tt class="docutils literal">
      concurrent.futures.Future
     </tt>
     .
    </li>
    <li>
     <a class="reference external" href="../pep-3153/index.html">
      PEP 3153
     </a>
     , while rejected, has a good write-up explaining the need
to separate transports and protocols.
    </li>
    <li>
     <a class="reference external" href="../pep-0418/index.html">
      PEP 418
     </a>
     discusses the issues of timekeeping.
    </li>
    <li>
     Tulip repo:
     <a class="reference external" href="http://code.google.com/p/tulip/">
      http://code.google.com/p/tulip/
     </a>
    </li>
    <li>
     PyPI: the Python Package Index at
     <a class="reference external" href="http://pypi.python.org/">
      http://pypi.python.org/
     </a>
    </li>
    <li>
     Nick Coghlan wrote a nice blog post with some background, thoughts
about different approaches to async I/O, gevent, and how to use
futures with constructs like
     <tt class="docutils literal">
      while
     </tt>
     ,
     <tt class="docutils literal">
      for
     </tt>
     and
     <tt class="docutils literal">
      with
     </tt>
     :
     <a class="reference external" href="http://python-notes.boredomandlaziness.org/en/latest/pep_ideas/async_programming.html">
      http://python-notes.boredomandlaziness.org/en/latest/pep_ideas/async_programming.html
     </a>
    </li>
    <li>
     TBD: references to the relevant parts of Twisted, Tornado, ZeroMQ,
pyftpdlib, libevent, libev, pyev, libuv, wattle, and so on.
    </li>
   </ul>
  </div>
  <div class="section" id="acknowledgments">
   <h1>
    <a class="toc-backref" href="#id57">
     Acknowledgments
    </a>
   </h1>
   <p>
    Apart from
    <a class="reference external" href="../pep-3153/index.html">
     PEP 3153
    </a>
    , influences include
    <a class="reference external" href="../pep-0380/index.html">
     PEP 380
    </a>
    and Greg Ewing's
tutorial for
    <tt class="docutils literal">
     yield from
    </tt>
    , Twisted, Tornado, ZeroMQ, pyftpdlib, and
wattle (Steve Dower's counter-proposal).  My previous work on
asynchronous support in the NDB library for Google App Engine provided
an important starting point.
   </p>
   <p>
    I am grateful for the numerous discussions on python-ideas from
September through December 2012, and many more on python-tulip since
then; a Skype session with Steve Dower and Dino Viehland; email
exchanges with and a visit by Ben Darnell; an audience with Niels
Provos (original author of libevent); and in-person meetings (as well
as frequent email exchanges) with several Twisted developers,
including Glyph, Brian Warner, David Reid, and Duncan McGreggor.
   </p>
   <p>
    Contributors to the implementation include
Eli Bendersky,
Gustavo Carneiro (Gambit Research),
Saúl Ibarra Corretgé,
Geert Jansen,
A. Jesse Jiryu Davis,
Nikolay Kim,
Charles-François Natali,
Richard Oudkerk,
Antoine Pitrou,
Giampaolo Rodolá,
Andrew Svetlov,
and many others who submitted bugs and/or fixes.
   </p>
   <p>
    I thank Antoine Pitrou for his feedback in his role of official PEP
BDFL.
   </p>
  </div>
  <div class="section" id="copyright">
   <h1>
    <a class="toc-backref" href="#id58">
     Copyright
    </a>
   </h1>
   <p>
    This document has been placed in the public domain.
   </p>
   <!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
  </div>
 </body>

<!-- Mirrored from www.python.org/dev/peps/pep-3156/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 03 Sep 2015 04:35:49 GMT -->
</html>Source: <a href="https://hg.python.org/peps/file/tip/pep-3156.txt">https://hg.python.org/peps/file/tip/pep-3156.txt</a>

    </article>


                </section>

                


<aside class="left-sidebar" role="secondary">

    






    





        <div class="twitter-widget sidebar-widget">
        <a class="twitter-timeline" data-dnt="true" href="https://twitter.com/ThePSF" data-widget-id="434113224703610882">Tweets by @ThePSF</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </div>

    <div class="psf-sidebar-widget sidebar-widget">
        <h3 class="widget-title">The PSF</h3>
<p>The Python Software Foundation is the organization behind Python. Become a member of the PSF and help advance the software and our mission. </p>

    </div>

</aside>



                
                


            </div><!-- end .container -->
        </div><!-- end #content .content-wrapper -->

        <!-- Footer and social media list -->
        <footer id="site-map" class="main-footer" role="contentinfo">
            <div class="main-footer-links">
                <div class="container">

                    
                    <a id="back-to-top-1" class="jump-link" href="#python-network"><span aria-hidden="true" class="icon-arrow-up"><span>&#9650;</span></span> Back to Top</a>

                    

<ul class="sitemap navigation menu do-not-print" role="tree" id="container">
    
    <li class="tier-1 element-1">
        <a href="https://www.python.org/about/" >About</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/about/apps/" title="">Applications</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/about/quotes/" title="">Quotes</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/about/gettingstarted/" title="">Getting Started</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/about/help/" title="">Help</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-2">
        <a href="https://www.python.org/downloads/" >Downloads</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/downloads/" title="">All releases</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/downloads/source/" title="">Source code</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/downloads/windows/" title="">Windows</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/downloads/mac-osx/" title="">Mac OS X</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/download/other/" title="">Other Platforms</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://docs.python.org/3/license.html" title="">License</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/download/alternatives" title="">Alternative Implementations</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-3">
        <a href="https://www.python.org/doc/" >Documentation</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/doc/" title="">Docs</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/doc/av" title="">Audio/Visual Talks</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://wiki.python.org/moin/BeginnersGuide" title="">Beginner&#39;s Guide</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://docs.python.org/devguide/" title="">Developer&#39;s Guide</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://docs.python.org/faq/" title="">FAQ</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="http://wiki.python.org/moin/Languages" title="">Non-English Docs</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="../index.html" title="">PEP Index</a></li>
    
        <li class="tier-2 element-8" role="treeitem"><a href="https://wiki.python.org/moin/PythonBooks" title="">Python Books</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-4">
        <a href="https://www.python.org/community/" >Community</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/community/diversity/" title="">Diversity</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/community/irc/" title="">IRC</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/community/lists/" title="">Mailing Lists</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/community/workshops/" title="">Python Conferences</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/community/sigs/" title="">Special Interest Groups</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://wiki.python.org/moin/" title="">Python Wiki</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/community/logos/" title="">Python Logo</a></li>
    
        <li class="tier-2 element-8" role="treeitem"><a href="https://www.python.org/community/merchandise/" title="">Merchandise</a></li>
    
        <li class="tier-2 element-9" role="treeitem"><a href="https://www.python.org/community/awards" title="">Community Awards</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-5">
        <a href="https://www.python.org/about/success/" title="success-stories">Success Stories</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/about/success/#arts" title="">Arts</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/about/success/#business" title="">Business</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/about/success/#education" title="">Education</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/about/success/#engineering" title="">Engineering</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://www.python.org/about/success/#government" title="">Government</a></li>
    
        <li class="tier-2 element-6" role="treeitem"><a href="https://www.python.org/about/success/#scientific" title="">Scientific</a></li>
    
        <li class="tier-2 element-7" role="treeitem"><a href="https://www.python.org/about/success/#software-development" title="">Software Development</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-6">
        <a href="https://www.python.org/blogs/" title="News from around the Python world">News</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/blogs/" title="Python Insider Blog Posts">Python News</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="http://planetpython.org/" title="Planet Python">Community News</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="http://pyfound.blogspot.com/" title="PSF Blog">PSF News</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="http://pycon.blogspot.com/" title="PyCon Blog">PyCon News</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-7">
        <a href="https://www.python.org/events/" >Events</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="https://www.python.org/events/python-events/" title="">Python Events</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="https://www.python.org/events/python-user-group/" title="">User Group Events</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://www.python.org/events/python-events/past/" title="">Python Events Archive</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="https://www.python.org/events/python-user-group/past/" title="">User Group Events Archive</a></li>
    
        <li class="tier-2 element-5" role="treeitem"><a href="https://wiki.python.org/moin/PythonEventsCalendar#Submitting_an_Event" title="">Submit an Event</a></li>
    
</ul>

        
    </li>
    
    <li class="tier-1 element-8">
        <a href="https://www.python.org/dev/" >Contributing</a>
        
            

<ul class="subnav menu">
    
        <li class="tier-2 element-1" role="treeitem"><a href="http://docs.python.org/devguide/" title="">Developer&#39;s Guide</a></li>
    
        <li class="tier-2 element-2" role="treeitem"><a href="http://bugs.python.org/" title="">Issue Tracker</a></li>
    
        <li class="tier-2 element-3" role="treeitem"><a href="https://mail.python.org/mailman/listinfo/python-dev" title="">python-dev list</a></li>
    
        <li class="tier-2 element-4" role="treeitem"><a href="http://pythonmentors.com/" title="">Core Mentorship</a></li>
    
</ul>

        
    </li>
    
</ul>


                    <a id="back-to-top-2" class="jump-link" href="#python-network"><span aria-hidden="true" class="icon-arrow-up"><span>&#9650;</span></span> Back to Top</a>
                    

                </div><!-- end .container -->
            </div> <!-- end .main-footer-links -->

            <div class="site-base">
                <div class="container">
                    
                    <ul class="footer-links navigation menu do-not-print" role="tree">
                        <li class="tier-1 element-1"><a href="https://www.python.org/about/help/">Help &amp; <span class="say-no-more">General</span> Contact</a></li>
                        <li class="tier-1 element-2"><a href="https://www.python.org/community/diversity/">Diversity <span class="say-no-more">Initiatives</span></a></li>
                        <li class="tier-1 element-3"><a href="https://github.com/python/pythondotorg/issues">Submit Website Bug</a></li>
                        <!--<li class="tier-1 element-3"><a href="#"><span class="say-no-more">Website</span> Colophon</a></li>-->
                    </ul>

                    <div class="copyright">
                        <p><small>
                            <span class="pre">Copyright &copy;2001-2015.</span>
                            &nbsp;<span class="pre"><a href="https://www.python.org/psf-landing/">Python Software Foundation</a></span>
                            &nbsp;<span class="pre"><a href="https://www.python.org/about/legal/">Legal Statements</a></span>
                            &nbsp;<span class="pre"><a href="https://www.python.org/privacy/">Privacy Policy</a></span>
                        </small></p>
                    </div>

                </div><!-- end .container -->
            </div><!-- end .site-base -->

        </footer>

    </div><!-- end #touchnav-wrapper -->

    
    <script src="../../../../ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../../static/js/libs/jquery-1.8.2.min.js"><\/script>')</script>

    <script src="../../../static/js/libs/masonry.pkgd.min.js"></script>

    <script type="text/javascript" src="../../../static/js/main-min.js" charset="utf-8"></script>
    

    <!--[if lte IE 7]>
    <script type="text/javascript" src="/static/js/plugins/IE8-min.js" charset="utf-8"></script>
    
    
    <![endif]-->

    <!--[if lte IE 8]>
    <script type="text/javascript" src="/static/js/plugins/getComputedStyle-min.js" charset="utf-8"></script>
    
    
    <![endif]-->

    

    
    

</body>
</html>
